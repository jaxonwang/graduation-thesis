#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\begin_preamble
\usepackage{pythonhighlight}

\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman SimSun
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
绪论
\end_layout

\begin_layout Section
课题背景
\end_layout

\begin_layout Subsection
推荐系统介绍
\end_layout

\begin_layout Standard
互联网的普及让人类进入了信息时代，各种各样的信息唾手可得。根据粗略估计，互联网每日产生的数据量已经达到EB的级别。这么多的数据导致了信息过载，用户面对这样庞大的
数据，很难手动从中过滤掉无用的信息，筛选出有价值的信息。比如互联网电商，社交网站，新闻网站中，充斥着数以百万计的物品信息，对于用户来说，不可能完整地一一浏览过滤
。针对数据过载这一问题，信息检索、数据挖掘、预测推荐等技术得到了广泛的应用。
\end_layout

\begin_layout Standard
搜索引擎是信息检索技术的集大成者。当今世界上搜索引擎Google一家独大，用户可以通过向搜索引擎提供关键词来获得搜索结果。同时，搜索引擎也可以通过数据挖掘技术为
不同类别的信息分类或者提供标签。但是如果用户向搜索引擎提供的信息有限，甚至不知道什么才是自己所需要的，那么搜索引擎就不能很好地解决信息过载这一问题
\begin_inset CommandInset citation
LatexCommand cite
key "许海玲2009互联网推荐系统比较研究"

\end_inset

。此时就需要能根据用户的喜好与品味给用户提供合适推荐的推荐系统了。
\end_layout

\begin_layout Standard
推荐系统又叫个性化推荐系统
\begin_inset CommandInset citation
LatexCommand cite
key "2421220"

\end_inset

，是信息过滤系统的一个子集，它尝试预测用户可能对一个物品的“评分”和“喜好程度”
\begin_inset CommandInset citation
LatexCommand cite
key "39360168"

\end_inset

。相对于非个性化推荐结果，如搜索引擎返回的结果，个性化搜索引擎更加依赖与用户的行为数据。个性化推荐系统需要在大量的用户数据中挖掘用户与物品之间内在的关联性，根据
这些知识来为对用户进行推荐。推荐系统被证明是解决信息过载问题的一个有效工具，具体地来说，从用户的显式或者隐式信息中提取有效的部分，进行建模来分析用户的品味和喜好
，再把用户可能喜欢的物品进行排序，对用户进行个性化的推荐。
\end_layout

\begin_layout Standard
推荐系统广泛地应用于互联网各大网站。通过推荐系统，能够很好地抓住用户的口味，符合用户的个性，大大提高了用户的转化率，为企业带来巨大的利润。下边介绍几种典型的应用
领域。
\end_layout

\begin_layout Enumerate
电子商务 电子商务网站是推荐系统被广泛应用的一个领域之一。亚马逊是著名的电子网站，它把推荐系统应用到了极致,也是最早应用推荐系统的网站之一。它提出来名为item
-to-item的协同过滤算法
\begin_inset CommandInset citation
LatexCommand cite
key "861437"

\end_inset

，推动了推荐系统邻域的发展。为后来用户登录后，它在首页为用户提供了个性化推荐列表。其中在每一样商品下方提供了其他商品的推荐，这些商品往往是其他用户最可能同时购买
的，并对打包购买提供一定的折扣。
\end_layout

\begin_layout Enumerate
电影视频网站 在电影视频网站中，使用推荐系统能够帮助用户找到他们喜欢的视频。Youtube目前是全球最大的视频网站，拥有大量的用户数据已经大量的视频。Youtu
be通过应用推荐系统，大大增加了用户的视频点击率。根据实验，个性化推荐相对与非个性化推荐有两倍多点击率
\begin_inset CommandInset citation
LatexCommand cite
key "39238972"

\end_inset

。 
\end_layout

\begin_layout Enumerate
音乐网络电台 音乐网络电台为用户提供了音乐点播服务，如果能准确地向用户推荐他喜爱的音乐那么会极大地增加用户的黏度。国内一个著名的音乐电台是
\begin_inset CommandInset href
LatexCommand href
name "douban.fm"
target "douban.fm"

\end_inset

，它为用户提供对歌曲喜欢或者删除的接口，户收集用户对歌曲的反馈，从而提供准确的推荐。
\end_layout

\begin_layout Enumerate
社交网络 社交网络包含巨大的用户之间的社交信息。Facebook是社交网络的一个代表。它利用了用户的社交信息、偏好信息来推荐物品。Facebook对外提供了一个
推荐API，可给用户推荐其好友喜欢的物品。
\end_layout

\begin_layout Subsection
推荐系统的功能
\end_layout

\begin_layout Standard
Herlocker等人
\begin_inset CommandInset citation
LatexCommand cite
key "804401"

\end_inset

定义了一些推荐系统的主要任务，其中常见的主要任务有寻找适合推荐的物品、从一组物品中进行推荐、收集并改进用户数据、为推荐提供解释等功能。个性化推荐系统最基本的功能
是为用户提供符合他们口味的推荐。一个好的推荐系统应该具备下列几种能力，它们从不同的角度有效的应对了目前信息过载的这个问题
\begin_inset CommandInset citation
LatexCommand cite
key "39360168"

\end_inset

。
\end_layout

\begin_layout Enumerate
增加物品转换率。转化率指的是潜在客户完成一次商家期望的行动的比率。对于互联网电商而言，商品的售出可以看作是一次成功的转化。也就是一个好的推荐系统能够为电商向用户
出售更多的商品，带来更大的收益。原因是因为推荐的物品更加地符合用户的口味，更够强烈地激发起用户的购买欲望。对于非电商网站，比如豆瓣电台，虽然没有金额消费的发生，
但是转化可以表现为用户对于某个音乐的欣赏时间长、将其加入一收藏夹、鼠标点击“喜欢”等等。一个好的推荐系统它能够有效得增加物品的转化率。
\end_layout

\begin_layout Enumerate
提供多样化的推荐。比如对于Netflix电影推荐，推荐系统能够提不同类别的DVD推荐，而不是仅仅推荐热门的物品，多样化的推荐能够让用户发现那些冷门而他们喜爱的物
品。也只有推荐系统能够有这样挖掘冷门物品的能力，因为从利益角度来看，商家对这样的的物品进行大肆宣传是有极大的风险的。
\end_layout

\begin_layout Enumerate
增加用户的粘性。一个好的推荐系统它也能很大程度上给用户带来用户体验的增加。用户会感受到推荐很有吸引力，和自己的兴趣相关，那么他会更加的愿意使用这个系统，最终增加
了用户的满意度。同时，符合他口味的推荐让他也能感受到商家对自己的重视，增加用户的忠诚度。
\end_layout

\begin_layout Standard
上述的推荐系统的主要功能是从作为一个完整的可投入使用的系统角度来提出的。其中这些功能我们最常见的一个体现就是生成TopN推荐，如亚马逊的首页提供的TopN推荐，
见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:亚马逊topN"

\end_inset

。而推荐评分预测问题是实现这些功能的一个基础。评分预测以某个用户未评分的物品为输入，产生对该用户给这个物品的评分的预测作为输出。产生的评分预测可以用于为推荐系统
作出推荐的一个重要参考。推荐系统的评分预测很容易用离线实验的方式来进行评估，通过对照预测值与真实值，用几种误差度量的方法来量化预测结果的准确性质。平凡预测问题主
要集中在学术界，本文也是主要致力于推荐系统产生预测的评分。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename 亚马逊推荐.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:亚马逊topN"

\end_inset

Amazon首页提供的TopN推荐
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
生成推荐的方式
\begin_inset CommandInset label
LatexCommand label
name "sub:生成推荐的方式"

\end_inset


\end_layout

\begin_layout Standard
根据上文所提到的，个性化推荐系统首先通过日志、数据等数据源分析用户的历史行为了解用户的兴趣，接着通过获取的兴趣来寻找符合用户口味的物品。主要有这么几种生成推荐的
方式
\begin_inset CommandInset citation
LatexCommand cite
key "2155197"

\end_inset

：
\end_layout

\begin_layout Enumerate
基于内容的推荐(content-based recommendation) 基于内容的推荐是利用已有的物品或者用户的信息，将其固有的特征抽离出来。物品信息抽离的
方式可以由人工得打上标签或者通过分类算法获得，用户的特征可以从算法其历史记录中获取。根据用户的特征为其推荐符合特征的物品。比如在网络书店中，一个用户他特征是“c
++程序员”，那么推荐系统很有可能为他推荐具有相同或者相似特征的书籍《c++ primer》。决策树、线性分类、朴素贝叶斯等方式常被应用于基于内容的推荐
\begin_inset CommandInset citation
LatexCommand cite
key "4117651"

\end_inset

。但是基于内容的推荐需要对数据进行预处理以获取特征，但是这个步骤在实际上非常困难的，比如给定一段音乐，想要计算机自动分析出它的音乐风格，需要很高的技术要求。其次
，基于内容的推荐产生的推荐往往局限在用户对应的特征中，导致推荐单一，很难发掘到用户潜在的兴趣。
\end_layout

\begin_layout Enumerate
协同过滤（collaborative算 filtering） 和基于内容的推荐不同，协同过滤推荐不需要对物品的特性有了解，它关注的是用户与物品之间的联系。通过对
历史记录的分析，了解用户与物品直接的联系，这些联系将会作为产生推荐的依据。比如一个人今天打算去看电影，他在选择电影前会问一问他的朋友最近看过什么电影，而他朋友的
过去选择将会影响他未来的选择，这就是协同过滤的核心思想。传统的两种协同过滤算法有基于用户的（user-based）和基于物品的（item-based）协同过滤。
基于用户的协同过滤基于这么一个假设：过去兴趣相似的用户在不远的未来将会保持相似的兴趣
\begin_inset CommandInset citation
LatexCommand cite
key "774803"

\end_inset

。协同过滤算法存在这样的问题：由于协同过滤依赖与用户的于研究评分预测问题。历史行为，那么推荐系统基于用户的（user-based）和基于物品的（item-bas
ed）协同过滤。基于用户的协同过滤将不知道为一个没有历史记录的新用户提供什么样的推荐。这个问题被称作冷启动问题(cold start)。冷启动问题的研究是推荐系
统领域的一个热门方向。
\end_layout

\begin_layout Enumerate
基于知识的推荐（Knowledge-based recommendation）基于知识的推荐是利用一些因果关系进行推理。比如一些商品用户往往只购买一次，然后在很
长一段时间内不会再对其进行再次购买。在用户购买这样的商品之后继续推荐类似的商品是不合适的。因此不应该把这一信息纳入到用户的兴趣中。在这种基于知识的推荐方式中，推
荐系统需要更多的信息，才能作出正确的推荐。基于知识的推荐很少单一使用，往往和其他方式组合起来，一起产生推荐。
\end_layout

\begin_layout Enumerate
混合推荐（Hybrid算 approaches）上述的几种方法有各自的优点和缺陷，混合推荐就是组合几种不同的推荐方式来互相弥补各种不足。如果一个推荐系统有额外的
社交信息可用，那么这个推荐系统可以通过混合推荐的方式来改进推荐结算果。混合推荐的一个典型的应用就是利用基于内容的推荐为协调过滤系统解决冷启动的问题。Kyung-
Yong Jun等人
\begin_inset CommandInset citation
LatexCommand cite
key "1793595"

\end_inset

将基于知识的推荐与基于内容的推荐组合起来，产生了更加精确的结果。对于评分预测问题，混合推荐也能达到更高的精确度。常用的
\end_layout

\begin_layout Standard
相对于其他的方式，协同推荐系统不需要人为地添加标签，大大减少了数据预处理时候产生的工作两。同时，协同过滤更擅长挖掘那些冷门的物品从而提供更多样化的推荐。最后协同
协同过滤算法在实际工程中表现出良好的推荐精确读。因此，协同过滤常常在个性化推荐系统中作为主要的方式被广泛使用。本文着重于研究协同过滤的方式。
\end_layout

\begin_layout Section
研究现状
\end_layout

\begin_layout Standard
推荐系统已经是机器学习，数据挖掘技术在工业界的一个代表性应用之一。伴随着市场的需求，越来越多的学者关注这一领域
\begin_inset CommandInset citation
LatexCommand cite
key "237066"

\end_inset

。著名的数据挖掘会议SIGKDD也开设了WEBKDD小组，用于研究电子商务技术以及推荐系统技术。在2001年，ACM的SIGIR为推荐系统开设了一个新的主题。2
007年，ACM Conference on Recommender Systems （简称RecSys）会议成立，直到2015年每年召开一次，它是是一个推荐系
统方向上的一个主要的会议。同时，越来越多的推荐系统或者相关内容的文章出现在著名的人工智能、数据挖掘、机器学习等领域的重要学术会议中，如AI Communicat
ions (2008); IEEE Intelligent Systems (2007); Inter-national Journal of
 Electronic Commerce (2006); International Journal of Com- puter Science
 and Applications (2006)等等。
\end_layout

\begin_layout Standard
在工业界，各大互联网公司的研发团队也着重致力于对推荐技术的研究。各大数据挖掘赛事也开设了许多推荐系统相关的项目。其中一个著名的比赛是
\begin_inset CommandInset href
LatexCommand href
name "Netflix Prize"
target "www.netflixprize.com"

\end_inset

，它由著名的在线电影公司Netlix举办。从2006年的第一届到2009年为止已经成功举办了三届。Netflix提供了他们的在线电影数据库，要求参赛者能在他们原
有的推荐系统Cinematch上至少提10%的高预测的准确率。冠军将会获得一百万美元的奖励。该赛事吸引了许多从事数据挖掘、推荐系统等领域的学者，并且在比赛中长生
了许多优秀的新算法，极大地推动了推荐系统领域的发展。
\end_layout

\begin_layout Standard
早期的推荐系统主要是基于内容的推荐，需要分析资源的内容信息
\begin_inset CommandInset citation
LatexCommand cite
key "303284,245168"

\end_inset

。由于分析资源内容信息较为困难以及难以提供的推荐物品的范围小等问题，研究者提出稀疏度了协调过滤的推荐方法
\begin_inset CommandInset citation
LatexCommand cite
key "777495,777206,774803,340335"

\end_inset

。GroupLens小组使用的是基于用户的协同过滤方法
\begin_inset CommandInset citation
LatexCommand cite
key "340335,774803"

\end_inset

，这种方法主要根据用户之间的相似度来提供推荐。Karypis等人在2001年提出基于物品的协同过滤方法
\begin_inset CommandInset citation
LatexCommand cite
key "804402,124971"

\end_inset

，并且在GroupLens数据集上获得了想对于基于用户的方法更加精确的结果
\begin_inset CommandInset citation
LatexCommand cite
key "499786"

\end_inset

。与基于用户的协同过滤不同，基于物品的协同过滤是根据物品之间的相似的来提供推荐的。文章
\begin_inset CommandInset citation
LatexCommand cite
key "107804"

\end_inset

提出基于图的算法来计算用户的相似度。协同过滤推荐面临的一个主要问题是数据的稀疏性，用户评分过的物品在总的物品集合中只占据了很小的一部分，对于一些噪声比较敏感，这
将会导致推荐质量的下降。对于这种问题，Sarwar等人
\begin_inset CommandInset citation
LatexCommand cite
key "205701"

\end_inset

采用奇异值分解（Singular Value Decomposition对 ）的方法来减少物品矩阵的维度，提高推荐的质量。Simon Funk等人
\begin_inset CommandInset citation
LatexCommand cite
key "NetflixUpdateTryThisatHome"

\end_inset

在SVD基础上作出了优化，在Netflix Prize上取得了优异的结果，后来被称作隐语模型（Latent Factor Model）。
\end_layout

\begin_layout Standard
由于用户与物品的数量庞大，进行一次离线计算将花费大量的时间，推荐结果的时效性难以保障。针对这一问题，不同学者也提出了一些优化的方法。上述奇异值分解是一个有效的方
法。文章
\begin_inset CommandInset citation
LatexCommand cite
key "1284393,485233,295125"

\end_inset

采用聚类的方法，把用户分为几个簇，在在簇内进行寻找邻居，而不是在全局范围内搜索邻居，减少了计算量。文章
\begin_inset CommandInset citation
LatexCommand cite
key "56775"

\end_inset

提出了一种RecTree的算法来减少搜索空间。
\end_layout

\begin_layout Section
本文工作
\end_layout

\begin_layout Subsection
本文研究内容的与成果
\end_layout

\begin_layout Standard
针对目前推荐系统的一些问题，本文主要研究推荐系统的架构以及算法的设计。本文使用的是MovieLens的数据集，采用协同过滤的方法对用户提供评分预测。本文主要工作
内容如下：
\end_layout

\begin_layout Standard
1.推荐引擎TinyRec设计与实现。目前各大互联网公司使用的都是自己开发的推荐系统，开源的推荐框架并不是很多，针对这种情况，本文给出了一个推荐引擎TinyRec
的实现。一个完整的推荐系统除了推荐引擎之外，包括前台web展示页面的支持以及数据收集清洗模块以及后台复杂的业务流程。本文目前实现的是提供评分预测的一个推荐引擎。
TinyRec是一个轻量级的推荐引擎，可以作为一个推荐框架使用。它可以从给定的数据集中读取数据并将其结构化。它提供不同的数据存储方式的支持，可以支持基于内存的数
据库如Redis，也可以支持关系型数据库。它可以通过配置文件灵活得选择各种算法。它还提供了根据推荐结果计算推荐精确度的功能。TinyRec为本文各种算法研究以及
推荐结果分析提供了支持。
\end_layout

\begin_layout Standard
2.协同过滤算法的设计与实现。本文分别给出了主流的基于用户的协同过滤算法和基于物品的协调过滤算法的实现。对于不同的相似度算法，如余弦相似度、pearson相关系数
、spearman相关系数，本文研究了一些实现的细节。针对协同过滤算法用户对物品评分的稀疏性问题，本文还实现了一个简单的稀疏向量的运算库。针对协同过滤算法复杂度
高这一问题，本文给出了算法并行化的实现，使之能够更加充分得利用计算资源，减少计算时间。
\end_layout

\begin_layout Standard
3.各种协同过滤算法的比较与分析。目前，对于一个协同过滤的推荐引擎，存在许多算法的选择。比如对于基于用户的协调同推荐算法的相似度度量方式，就有余弦相似度、pear
son相关系数、spearman相关系数这几种，对于每种相似度度量方式，就有不同的修正方式。比如使用pearson相关系数的相似度度量算法可以选择默认评分填补（
Default Voting）、重要性权重（Significance Weighting）等修正方式。同时相同算法下也有不同可选的参数，比如采用KNN来进行评分
预测时候邻域大小K值的选择也会影响预测的结果。本文通过控制变量的方式，研究了不同的算法、相同算法下不同参数的选择对的评分预测精度影响，并根据结果给出了分析。最终
分析了不同协同过滤算法的特性以及在实际应用中的选择考虑。
\end_layout

\begin_layout Subsection
本文结构
\begin_inset CommandInset label
LatexCommand label
name "sub:本文结构"

\end_inset


\end_layout

\begin_layout Standard
本文一共分为五章，文章结构以及各章内容如下：
\end_layout

\begin_layout Standard
第一章介绍了推荐系统这个课题的背景以及其研究研究现状，介绍了推荐系统的任务以及基本的方法。还讨论了目前推荐技术面临的主要挑战，还探讨了其研究意义，给出了本文的结
构。最后规定了本文使用的术语和记号。
\end_layout

\begin_layout Standard
第二章主要介绍协同过滤推荐的关键技术。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:基于用户的协同过滤"

\end_inset

和章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:基于物品的协同过滤"

\end_inset

分别介绍了两种最常用的协同过滤算法：基于用户的协同过滤以及基于物品的协同过滤。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

描述了几种常见的相似度度量方法。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:评分标准化"

\end_inset

介绍的评分标准化方法是推荐算法挖掘内在关联的必要过程。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:用K邻近算法预测"

\end_inset

讨论了邻域选取的几种方法，最后章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:预测精确率度量"

\end_inset

介绍了如何度量算法的精确度。
\end_layout

\begin_layout Standard
第三章给出了一个推荐引擎的实现，这一章介绍了推荐引擎TinyRec的设计方法并给出了部分代码，这些代码都经过修改，去除了一些不必要的细节，方便读者阅读。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:系统功能模块划分"

\end_inset

和章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:系统体系结构设计"

\end_inset

介绍了引擎TinyRec的系统模块划分以及系统的架构设计。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:功能模块的设计与实现"

\end_inset

则给出了系统中各个模块的具体的设计，介绍了其中设计的方法和思想。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:算法设计与实现"

\end_inset

着重于推荐算法的实现，介绍了TinyRec使用的几种相似度算法和预测算法。
\end_layout

\begin_layout Standard
第四章比较了不同算法的结果以及不同参数对算法精确性的影响。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:实验数据与度量标准"

\end_inset

介绍了实验使用的数据以及使用的度量标准，章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:实验方法"

\end_inset

描述了实验的方法以及过程。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:实验内容及结果"

\end_inset

则是给出了不同的实验结果及对结果的分析，并且比较了不同算法的特性。
\end_layout

\begin_layout Standard
第五章则对本文作出一个总结，对现有问题进行归纳，并对未来的工作作出展望。
\end_layout

\begin_layout Section
术语和记号
\end_layout

\begin_layout Standard
在协同过滤的算法的评分预测问题中，使用的数据集是由用户的评分记录所构成的，每一条记录最主要的内容可以用一个三维的向量表示：
\begin_inset Formula $\left(u,i,r\right)$
\end_inset

。它的意思是用户
\begin_inset Formula $u$
\end_inset

为物品
\begin_inset Formula $i$
\end_inset

给出了
\begin_inset Formula $r$
\end_inset

的打分。用户（user）指的是为物品打分的个体，物品（item）在其他文章中也称作商品，对于某种特点应用的推荐系统中，物品可以是电影、音乐、文章等，本文中都称为
物品。评分可以体现用户对物品的喜爱程度，它可以从用户主动提供的显式评分，如打分，喜欢等方式获得，也可以根据用户在页面上的行为获取隐式评分，比如页面停留时间、物品
的转换、页面的点击等等。本文讨论的评分是由MovieLens数据集直接给出的评分，是用户的显式地为电影作出的打分。其有效评分范围1～5分，分值为整数。本文的讨论
的评分都是按照这种机制。是在本文中，集合使用大写英文字母表示。
\end_layout

\begin_layout Standard
本文中，数据集被分割为两个部分，训练数据集（training dataset）和测试数据集（testing dataset）。用于挖掘关联关系的训练数据集记为
\begin_inset Formula $Tr$
\end_inset

，用于检验算法的测试数据集记为
\begin_inset Formula $Ts$
\end_inset

。具体的记号见表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:本文术语表格"

\end_inset

。更多特点算法相关的记号会在文章中指出。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
记号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
定义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
可用的评分集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $U$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有用户的集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有物品的集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
第
\begin_inset Formula $u$
\end_inset

个用户
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $i$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
第
\begin_inset Formula $i$
\end_inset

个物品
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $r_{u,i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\begin_inset Formula $u$
\end_inset

对物品
\begin_inset Formula $i$
\end_inset

的评分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
对于
\begin_inset Formula $r_{u,i}$
\end_inset

的预测值
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{r_{u}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\begin_inset Formula $u$
\end_inset

的平均打分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{r_{i}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
物品
\begin_inset Formula $i$
\end_inset

的平均打分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $U_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有评价过物品
\begin_inset Formula $i$
\end_inset

的用户集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{u}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\begin_inset Formula $u$
\end_inset

评价过的所有物品集合
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:本文术语表格"

\end_inset

本文中使用的各种记号与术语
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
协同过滤推荐关键章节技术条件介绍
\end_layout

\begin_layout Section
基于邻域的评分预测
\end_layout

\begin_layout Standard
协同过滤问题常常可以表示为一subsection{推荐系统介绍} 个用户对物品的矩阵，在这个矩阵中每个元素代表一个用户对特点物品的评分。由于协同过滤问题的特点，
这个矩阵非常稀疏
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

，因为一个用户通常只评价了占物品集合中很小一部分的物品。对于一个基于邻域的评分预测就是要根据用户的领域来找出这个矩阵的某个空值最可能的值。换句话说，一个用户给物
品的评分更加依赖于和他有相似兴趣的人或者其他可信任的数据源。为了说明这一核心思想，见表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:四个用户为电影的评分表格"

\end_inset

，表中有四个用户对四部电影的不同评分，评分取值范围为1～5分，空值表示该用户未能给该电影评分，而问号是我们即将要对其给出预测。首先张三和赵六的兴趣比较相似，因为
他们喜欢相同的电影，给星球章节大战和超时空接触打了高分，并且不怎么喜欢篮球梦。而对比赵六和剩下两个人的兴趣，发现他们的兴趣不是那么一致，因此张三给泰坦尼克的分数
将作为我们主要的参考来预测赵六的评分。而李四和王五的评分对预测结果的影响就非常小了。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星球大战
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
篮球梦
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
超时空接触
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
泰坦尼克
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
张三
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
李四
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
王五
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
赵六
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
？
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:四个用户为电影的评分表格"

\end_inset

一个电影评分预测的例子，四个用户为电影的评分表格
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
基于用户的协同过滤
\begin_inset CommandInset label
LatexCommand label
name "sub:基于用户的协同过滤"

\end_inset


\end_layout

\begin_layout Standard
基于用户的协同过滤是早期协调过滤推荐系统中最常用的算法。在1994年GroupLens小组采用基于用户的协同过滤算法来为用户提供新闻推荐
\begin_inset CommandInset citation
LatexCommand cite
key "340335"

\end_inset

。直到基于物品的协同过滤出现以前，它一直是推荐领域中最热门的算法。比如在一个个性化推荐系统中，用户A需要得到推荐时，推荐系统会先找到和它有相似兴趣的用户，把那些
用户喜欢的而用户A没有接触过的物品推荐给A。类似的，在评分预测问题中，基于用户的协同过滤通过寻找与目标用户最相似的一群用户，根据他们的打分情况来提供评分预测。基
于用户的协同过滤假设一群用户的兴趣在过去的历史记录中相似，那么在未来的一段时间内，他们的兴趣仍然相似。所以在用户A需要得到对于某个物品的推荐或者需要进行评分预测
时候，我们有足够的理由相信，和用户A有相同兴趣的那些用户对这个物品的评价与用户A将来对它的评价很相似。
\end_layout

\begin_layout Standard
通过以上表述，我们可以得出基于用户的协同过滤算法需要下边这两个过程；
\end_layout

\begin_layout Enumerate
寻找和目标用户相似的用户集合。
\end_layout

\begin_layout Enumerate
根据这个用户的集合里其他用户的评价，产生这个用户的评分预测。
\end_layout

\begin_layout Standard
为了寻找和目标用户相似的用户集合，我们首先得知道两个用户之间相似度的计算方法。常见的相似度计算方法在章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

中描述。假设我们需要为用户
\begin_inset Formula $u$
\end_inset

提供物品
\begin_inset Formula $i$
\end_inset

的评分预测
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

。首先我们在用户集合
\begin_inset Formula $U$
\end_inset

中找出评价过物品
\begin_inset Formula $i$
\end_inset

的用户集合
\begin_inset Formula $U{}_{i}$
\end_inset

，其中
\begin_inset Formula $u\notin U{}_{i}$
\end_inset

。接着两两计算用户
\begin_inset Formula $u$
\end_inset

与
\begin_inset Formula $U{}_{i}$
\end_inset

中的每个用户的相似度，挑选与
\begin_inset Formula $u$
\end_inset

相似的用户，我们得到了与用户
\begin_inset Formula $u$
\end_inset

最相似的用户集合，用
\begin_inset Formula $\mathcal{N}_{i}(u)$
\end_inset

表示。选取该最相似集合的方法在章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:用K邻近算法预测"

\end_inset

中描述。我们可以简单地使用来作为
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\frac{1}{\left|\mathcal{N}_{i}(u)\right|}\underset{v\in\mathcal{N}_{i}(u)}{\sum}r_{u,i}\label{eq:邻域内用户对i评分的平均值}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
上述公式假设我们需要为用户
\begin_inset Formula $u$
\end_inset

提供物品
\begin_inset Formula $i$
\end_inset

的评分预测
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

。
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:邻域内用户对i评分的平均值"

\end_inset

存在一个问题，它没有考虑到这样一个事实，在选取的邻域内的用户与目标用户
\begin_inset Formula $u$
\end_inset

有着不同的相似度，不同同相似度的用户在参与给出评分时的影响不同：相似度高的用户应当对结果有更大的影响。一个普遍的解决方法是，令两个用户之间的相似度作为权重，记为
\begin_inset Formula $w_{u,i}$
\end_inset

。此时公式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:邻域内用户对i评分的平均值"

\end_inset

可写作：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\frac{\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}r_{v,i}}{\underset{v\in\mathcal{N}_{i}(u)}{\sum}\left|w_{u,v}\right|}\label{eq:添加权重的评分}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
公式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:添加权重的评分"

\end_inset

更加符合我们的期望，其中注意到分母中
\begin_inset Formula $w_{u,i}$
\end_inset

使用了绝对值，是因为相似度可以正相关，也可以负相关，更多的讨论见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

。
\end_layout

\begin_layout Subsection
基于物品的协同过滤
\begin_inset CommandInset label
LatexCommand label
name "sub:基于物品的协同过滤"

\end_inset


\end_layout

\begin_layout Standard
相对于基于用户的协同过滤算法，基于物品的协同过滤算法注重于物品之间的相似度。它是Karypis等人在2001年提出基于的
\begin_inset CommandInset citation
LatexCommand cite
key "804402,124971"

\end_inset

，亚马逊的科学家也提出了相似的理论
\begin_inset CommandInset citation
LatexCommand cite
key "861437"

\end_inset

。基于物品相似度的一个特点是不同于用户之间的相似度，物品之间的相似度比较稳定，基本只要计算一次就可以长时间使用。用户之间的相似度可能随着用户评价更多的物品或者用
户的兴趣变化的而逐渐变化，因此过一段时间需要重新计算。基章节于物品的协同过滤基于这样的一个假设，有两个相似的物品A和B，对于一个特定的用户来说，该用户对物品A的
评价应该和对于物品B的评价接近。类似与基于用户的协同过滤算法，基于物品的协同过滤算法可以分为下边几个步骤：
\end_layout

\begin_layout Enumerate
在用户参与过评分的物品中寻找与目标商品相似的物品集合。
\end_layout

\begin_layout Enumerate
根据该用户给相似的物品集合中物品的评分给出目标商品的预测评分。
\end_layout

\begin_layout Standard
我们可以在寻找相似物品集合之前先计算好物品之间的相似度。我们也可以用
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

中描述的相似读计算方法来计算。这一过程可以形式化地描述为，为了给用户
\begin_inset Formula $u$
\end_inset

提供物品
\begin_inset Formula $i$
\end_inset

的评分预测
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

，我们必须找到和用户
\begin_inset Formula $u$
\end_inset

评分过的物品中与物品
\begin_inset Formula $i$
\end_inset

最相似的物品集合
\begin_inset Formula $\mathcal{N}_{u}(i)$
\end_inset

。我们把两个物品之间的相似度作为权重
\begin_inset Formula $w$
\end_inset

，那么可以这样来描述评分预测的公式：
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\frac{\underset{j\in\mathcal{N}_{u}(i)}{\sum}w_{i,j}r_{u,j}}{\underset{j\in\mathcal{N}_{u}(j)}{\sum}\left|w_{i,j}\right|}\label{eq:基于物品的评分}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
相似度度量方法
\begin_inset CommandInset label
LatexCommand label
name "sub:相似度度量方法"

\end_inset


\end_layout

\begin_layout Subsubsection
余弦相似度
\begin_inset CommandInset label
LatexCommand label
name "sub:余弦相似度"

\end_inset


\end_layout

\begin_layout Standard
一种最基本的计算两个个体的相似读的方法是余弦相似度
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。余弦相似度计算两个向量之间的夹角，其取值范围为
\begin_inset Formula $(-1,1)$
\end_inset

。夹角越小，表示两个向量之间正相关度越高，越接近1，反之则接近-1，表现出负相关性。设两个向量为
\begin_inset Formula $\mathbf{x}_{a}$
\end_inset

、
\begin_inset Formula $\mathbf{x}_{b}$
\end_inset

，则他们之间的相似度可以表示为：
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{a},\mathbf{x}_{b})=\frac{\mathbf{x}_{a}^{\top}\mathbf{x}_{b}}{\left\Vert \mathbf{x}_{a}\right\Vert \left\Vert \mathbf{x}_{b}\right\Vert }\label{eq:cos相似度}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
在基于用户的协同推荐算法中，我们可以用式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度"

\end_inset

来表示两个用户
\begin_inset Formula $u$
\end_inset

和
\begin_inset Formula $v$
\end_inset

之间的相似度。我们把用户
\begin_inset Formula $u$
\end_inset

看作是一个向量
\begin_inset Formula $\mathbf{x}_{u}\in\mathbb{R}^{\left|I\right|}$
\end_inset

,其中如果用户
\begin_inset Formula $u$
\end_inset

给物品
\begin_inset Formula $i$
\end_inset

有过评分，那么
\begin_inset Formula $\mathbf{x}_{ui}=r_{u,i}$
\end_inset

，其他则为0。那么式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度"

\end_inset

可写成：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{u},\mathbf{x}_{v})=\frac{\underset{i\in I_{u}\cap I_{v}}{\sum}r_{u,i}r_{v,i}}{\sqrt{\underset{i\in I_{u}}{\sum r_{u,i}^{2}}\underset{j\in I_{v}}{\sum r_{v,j}^{2}}}}\label{eq:cos相似度基于用户}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
在基于物品的协同过滤算法中，类似的我们把物品
\begin_inset Formula $i$
\end_inset

看作是一个向量
\begin_inset Formula $\mathbf{\bar{r_{v}})x}_{i}\in\mathbb{R}^{\left|U\right|}$
\end_inset

，如果用户
\begin_inset Formula $u$
\end_inset

给物品
\begin_inset Formula $i$
\end_inset

有过评分，那么
\begin_inset Formula $\mathbf{x}_{iu}=r_{u,i}$
\end_inset

，其他则为0。那么两个物品
\begin_inset Formula $i$
\end_inset

，
\begin_inset Formula $j$
\end_inset

的相似读可写成：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{i},\mathbf{x}_{j})=\frac{\underset{u\in U_{i}\cap U_{j}}{\sum}r_{u,i}r_{u,j}}{\sqrt{\underset{u\in U_{i}}{\sum r_{u,i}^{2}}\underset{v\in U_{j}}{\sum r_{v,j}^{2}}}}\label{eq:cos相似度基于物品}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
余弦相似度可以进一步根据用户个人的打分习惯来调整章节，见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:用K邻近算法预测"

\end_inset


\end_layout

\begin_layout Subsubsection
pearson相关系数
\begin_inset CommandInset label
LatexCommand label
name "sub:pearson相关系数"

\end_inset


\end_layout

\begin_layout Standard
pearson相关系数可以用于衡量一组数据的线性相关程度。与余弦相似度相似，相关系数的绝对值越大，相关程度越高。给定两组离散的数据x，y我们可以计算他们的pea
rson相关系数，其中
\begin_inset Formula $\sigma$
\end_inset

表示为数据的标准差,
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mu$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
表示均值：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Pearson(x,y)=\frac{E\text{(}(x-\mu_{x})(y-\mu_{y}))}{\sigma_{x}\sigma_{y}}\label{eq:pearson base}
\end{equation}

\end_inset

在基于用户的协同推荐算法中，用户u和用户v之间的pearson相关系数为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{uv}=Pearson(u,v)=\frac{\underset{i\in I_{u}\cap I_{v}}{\sum}(r_{u,i}-\bar{r_{u}})\cdotp(r_{v,i}-\bar{r_{v}})}{\sqrt{\underset{i\in I_{u}}{\sum}(r_{u,i}-\bar{r_{u}})^{2}\underset{i\in I_{v}}{\sum}(r_{v,i}-\bar{r_{v}})^{2}}}\label{eq:pearson user base-}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
在基于物品的协同推荐算法中，物品
\begin_inset Formula $i$
\end_inset

和物品
\begin_inset Formula $j$
\end_inset

之间的pearson相关系数为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{ij}=Pearson(i,j)=\frac{\underset{u\in U_{i}\cap U_{j}}{\sum}(r_{u,i}-\bar{r_{i}})\cdotp(r_{u,j}-\bar{r_{j}})}{\sqrt{\underset{u\in U_{i}}{\sum}(r_{u,i}-\bar{r_{i}})^{2}\underset{u\in U_{j}}{\sum}(r_{u,i}-\bar{r_{j}})^{2}}}\label{eq:pearson item base}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
pearson相关系数是依赖与数据符合正态分布的假设，不过大部分实际的数据都能符合这个假设。如果假设不成立的话，可以使用
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:spearman秩相关系数"

\end_inset

描述的spearman相关系数。
\end_layout

\begin_layout Subsubsection
spearman秩相关系数
\begin_inset CommandInset label
LatexCommand label
name "sub:spearman秩相关系数"

\end_inset


\end_layout

\begin_layout Standard
和pearson相关系数不同，spearman秩相关系数不对原始变量作特殊的要求，因此对于不服从正态分布、分布未知的变量可以使用spearman秩相关系数。sp
earman秩相关系数计算时先把变量X，Y成对的值从哦按照从小到大的顺序排列，将原始的数值映射成秩，再按照pearson相关系数来计算相关度。
\end_layout

\begin_layout Standard
在基于用户的协同过滤算法中，设用户
\begin_inset Formula $u$
\end_inset

，
\begin_inset Formula $v$
\end_inset

的评分被映射成
\begin_inset Formula $rank$
\end_inset


\begin_inset Formula $_{u}$
\end_inset

，
\begin_inset Formula $rank_{v}$
\end_inset

，秩的平均值为
\begin_inset Formula $\overline{rank_{u}}$
\end_inset

，
\begin_inset Formula $\overline{rank_{v}}$
\end_inset

，秩的标准差记为
\begin_inset Formula $\sigma_{u}$
\end_inset

，
\begin_inset Formula $\sigma_{v}$
\end_inset

,
\begin_inset Formula $m$
\end_inset

为共同评分的个数。则spearman秩相关系数为：
\begin_inset Formula 
\begin{equation}
w_{uv}=Spearman(u,v)=\frac{\sum_{i=1}^{m}(rank_{u,i}-\overline{rank_{u}})\cdotp(rank_{v,i}-\overline{rank_{v}})}{\sigma_{u}\sigma_{v}}\label{eq:spearman user base}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
相似的，基于物品的协同过滤算法中，spearman秩相关系数为：
\begin_inset Formula 
\begin{equation}
w_{ij}=Spearman(i,j)=\frac{\sum_{i=1}^{m}(rank_{i,u}-\overline{rank_{i}})\cdotp(rank_{j,u}-\overline{rank_{j}})}{\sigma_{i}\sigma_{j}}\label{eq:spearman user base-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
重要性权重（Significance Weighting）
\begin_inset CommandInset label
LatexCommand label
name "sub:重要性权重（Significance-Weighting）"

\end_inset


\end_layout

\begin_layout Standard
如果给定的两个用户之间可用的数据量很小，那么上述相关性度量方法将不能很客观的表现它们直接的相关度量，比如如下情况：在计算用户A和用户B的相似度时，用户A，B共同
评分过的物品只有X，Y，无论A和B为X，Y打了多少分，pearson相关系数和spearman秩相关系数总会给出绝对值为1的很高的相关性。而这与我们的期望所违背
。同时，从直觉上我们还认为，如果两个用户共同评价的物品越多，那么计算出的相似度就越具有参考价值。Herlocker 等人针对这个问题提出了重要性权重（Signi
ficance Weighting）这一解决方法
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。主要思想就是，在计算相似度的时候，给那些共同参与物品特别少的用户之间的相似度作出惩罚：
\begin_inset Formula 
\begin{equation}
w_{uv}^{\prime}=\frac{min\{\left|I_{u}\cap I_{v}\right|,\gamma\}}{\gamma}\times w_{uv}\label{eq:significance weighting user}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
类似的针对物品直接的相似度我们也可以使用如下的方法：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{ij}^{\prime}=\frac{min\{\left|U_{i}\cap U_{j}\right|,\gamma\}}{\gamma}\times w_{uv}\label{eq:significance weighting item}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
其中
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\gamma$
\end_inset

是一个参数，它表示一个阈值，如果相同物品，或者相同用户的数量小于这个阈值，该相似度就会收到惩罚，文章
\begin_inset CommandInset citation
LatexCommand cite
key "706157,JonathanLHerlocker1999An"

\end_inset

表明，当
\begin_inset Formula $\gamma>25$
\end_inset

时候，评分预测的精确度得到很大的提升，
\begin_inset Formula $\gamma=50$
\end_inset

时将会达到最好的结果。
\end_layout

\begin_layout Subsection
评分标准化
\begin_inset CommandInset label
LatexCommand label
name "sub:评分标准化"

\end_inset


\end_layout

\begin_layout Standard
在实际情况中，每个用户都有自己的打分习惯。有些人比较喜欢给电影打高分，个自己不喜欢的电影三分，有些人的打分则比较严厉，非常谨慎地打高分。我们在为用户作出平凡预测
的时候，应当考虑到这些情况，要根据每个人打分习惯的不同情况来提供预测。评分标准化的过程可以放在数据预处理阶段做，也可以调整计算公式。
\end_layout

\begin_layout Subsubsection
均值中心化
\begin_inset CommandInset label
LatexCommand label
name "sub:均值中心化"

\end_inset


\end_layout

\begin_layout Standard
均值中心化
\begin_inset CommandInset citation
LatexCommand cite
key "breese1998empirical"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "340335"

\end_inset

的思想是通过评分与标准值来比较，从而决定评分的情况。在使用余弦相似度计算相似度时候，可以调整式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度基于用户"

\end_inset

为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{u},\mathbf{x}_{v})=\frac{\underset{i\in I_{u}\cap I_{v}}{\sum}(r_{u,i}-\overline{r_{u}})(r_{v,i}-\overline{r_{u}})}{\sqrt{\underset{i\in I_{u}}{\sum(r_{u,i}-\overline{r_{u}}}\underset{j\in I_{v}}{)^{2}\sum(r_{v,j}}-\overline{r_{v}}})^{2}}\label{eq:cos相似度基于用户-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度基于物品"

\end_inset

同理，不再赘述。而pearson相关系数与spearman秩相关系数均考虑了均值的情况，所以不需要调整。在生成评分时，基于物品的协同过滤算法可以直接使用
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:基于物品的评分"

\end_inset

，因为选取的用户对其他物品的评分已经包含了用户的个人习惯。而对于基于用户的协同过滤算法则需要调整式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:添加权重的评分"

\end_inset

为：
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\overline{r_{u}}+\frac{\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}(r_{v,i}-\overline{r_{v}})}{\underset{v\in\mathcal{N}_{i}(u)}{\sum}\left|w_{u,v}\right|}\label{eq:基于用户的KNN-中心化}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Z分布
\end_layout

\begin_layout Standard
相对于均值中心化，Z分布考虑了用户评分的方差
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。比如，用户A打分时候，经常给分范围是1分到5分，而用户B大部分的评分都是三分。在这种情况下，用户B给一个物品打了五分的事实将会比A给出五分的事实更少见，因此表
现出B对这个这个物品更高的喜爱度。同样的，在基于用户和基于物品中使用Z分布来标准化时处理方法不同。基于用户的协同过滤中评分预测公式为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\overline{r_{u}}+\sigma_{u}\frac{\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}(r_{v,i}-\overline{r_{v}})/\sigma_{v}}{\underset{v\in\mathcal{N}_{i}(u)}{\sum}\left|w_{u,v}\right|}\label{eq:基于用户的zcore预测}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
其中，
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sigma_{u}$
\end_inset

和
\begin_inset Formula $\sigma_{v}$
\end_inset

分别表示用户u与用户v的评分的方差。同样的，对于基于物品的评分预测公式为:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\overline{r_{i}}+\sigma_{i}\frac{\underset{j\in\mathcal{N}_{u}(i)}{\sum}w_{i,j}(r_{u,i}-\overline{r_{j}})/\sigma_{j}}{\underset{j\in\mathcal{N}_{u}(i)}{\sum}\left|w_{i,j}\right|}\label{eq:基于物品的zcore预测}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
邻域选取
\begin_inset CommandInset label
LatexCommand label
name "sub:用K邻近算法预测"

\end_inset


\end_layout

\begin_layout Standard
在提供评分预测时，邻域的选取将会很大地影响到预测的结果。主要的邻域选取方式有如下几种
\end_layout

\begin_layout Itemize
Top-N选取。对于每个用户和物品，只要存储N个最相似的邻居，并且使用他们来进行预测。其中，N的选择非常重要，过低N值将会导致评分预测的准确率不知，而过高的N也
会带来准确率下降和是用大量计算资源
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。
\end_layout

\begin_layout Itemize
阈值选取。和Top-N过滤不同，阈值选取的方法选取所有能符合要求，即大于某个阈值的所有用户或者物品来作为邻居。这个方法更加灵活，只保留了那些对提供预测有最重要参
考意义的邻居，但是这个阈值的选取比较困难。
\end_layout

\begin_layout Itemize
负值过滤。使用由上文
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

提出的方法来计算相似度的区间范围是[
\begin_inset Formula $-1,1]$
\end_inset

。理论上来说，接近
\begin_inset Formula $-1$
\end_inset

的相似度表明两组数据间具有强烈的负相关性。但是在实际中，两个用户的的评分负相关只是表明这两个用户没有相似的兴趣，但是却没有表示出他们的兴趣究竟差了多少。直观上来
看，负相关也没有正相关对两个个体相似度的描述更有说服力。有实验证明
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An,good1999combining"

\end_inset

使用负值的相似度并不能带来更加准确的结果。本文中的实现没有使用负值的相似度。
\end_layout

\begin_layout Section
预测精确率度量
\begin_inset CommandInset label
LatexCommand label
name "sec:预测精确率度量"

\end_inset


\end_layout

\begin_layout Subsection
精确率度量方法
\begin_inset CommandInset label
LatexCommand label
name "sub:精确率度量方法"

\end_inset


\end_layout

\begin_layout Standard
平凡预测问题很容易离线地进行实验。常见的度量方法有均方根误差（RMSE）和平均绝对误差（MAE）。设
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

是推荐算法给用户
\begin_inset Formula $u$
\end_inset

对物品
\begin_inset Formula $i$
\end_inset

的评分预测，它预测的是根据测试数据集
\begin_inset Formula $Tr$
\end_inset

中的历史数据而给出的。设
\begin_inset Formula $r_{u,i}$
\end_inset

是在测试数据集
\begin_inset Formula $Ts$
\end_inset

中实际存在的评分那么RMSE可以通过下式计算：
\begin_inset Formula 
\begin{equation}
RMSE=\frac{\sqrt{\underset{u,i\in Ts}{\sum}(\hat{r}_{u,i}-r_{u,i})^{2}}}{\left|Ts\right|}\label{eq:RMSE}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
而平均绝对误差使用绝对值来计算：
\begin_inset Formula 
\begin{equation}
MAE=\frac{\underset{u,i\in Ts}{\sum}\left|\hat{r}_{u,i}-r_{u,i}\right|}{\left|Ts\right|}\label{eq:MAE}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Netflix认为RMSE对系统的评测更加严格，因为RMSE的平方项加大了对预测与实际的偏差的惩罚。在Netflix Prize中使用的也是RMSE来评判系统评
分预测结果的。而研究表明如果合法的评分是整数，那么对预测结果的取整后再进行精确度度量将会降低MAE的误差
\begin_inset CommandInset citation
LatexCommand cite
key "takacs2007major"

\end_inset

。
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:交叉验证与数据分割"

\end_inset

交叉验证与数据分割
\end_layout

\begin_layout Standard
交叉验证是一种统计学的方法，它将数据样本集合切割成多份，选取一部分用来分析，而剩余部分用来对此分析的确认和验证
\begin_inset CommandInset citation
LatexCommand cite
key "kohavi1995study"

\end_inset

。k-ford方法是一种常见的交叉验证方法。它平均地把原始数据集合分割成K份，挑选其中的一份作为测试集，剩余的部分作为训练集合。重复这样的过程K次，使得K份中的
每一份都能被选中作为测试集合。在机器学习领域中，k-ford方法能够有效地避免过度拟合和欠拟合的情况发生。在评分预测问题中，可以把原有数据集分成10份，分别作出
10次的评分预测以及验证精确度的过程。再取10次精确度结果的平均作为最终对算法精度的估计。其中K值选择为10是一个经验上的考虑。
\end_layout

\begin_layout Standard
在分割数据时，应当考虑如下的问题：分割时候应该对每个用户的所有评分做一次分割，这样能够最大限度地保证每个用户有足够的信息来为评分预测提供依据。比如两个用户A，B
的评分如表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:评分分割例子"

\end_inset

，我们需要将十个记录分割成两份，我们更希望分割的结果是
\begin_inset Formula $(1,3,5,6,8)$
\end_inset

和
\begin_inset Formula $(2,4,7,9,10)$
\end_inset

而不是
\begin_inset Formula $(1,2,3,4,5)$
\end_inset

和
\begin_inset Formula $(6,7,8,9,10)$
\end_inset

。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
记录序号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
电影名称
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
评分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星球大战
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星际迷航
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
泰坦尼克
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
低俗小说
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
阿甘正传
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
泰坦尼克
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星球大战
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
低俗小说
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星际迷航
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
阿甘正传
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:评分分割例子"

\end_inset

两个用户的评分例子
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
一个基于协同过滤的评分预测引擎TinyRec的实现 
\end_layout

\begin_layout Section
TinyRec总体介绍
\end_layout

\begin_layout Standard
为了给本文的算法实现、运行与检测提支持，本文实现了一个轻量集推荐引擎TinyRec。TinyRec的主要功能就是对已经经过预处理的数据进行计算分析，为用户提供评
分预测。TinyRec没有提供用户界面，而是和其他系统进行交互，提供推荐。TinyRec可以灵活地与各种算法结合，可以轻松地替换所需的算法，只需要用户实现所需算
法再修改下配置文件的参数。TinyRec还支持各种不同的数据存储方式，如关系型数据库，部分NoSQL数据库，以及文件等。不仅如此，TinyRec还提供了一些基本
的推荐系统所具备的功能，比如推荐精确度评估、数据分割、交叉验证等功能。TinyRec全部使用python语言
\begin_inset Foot
status open

\begin_layout Plain Layout
使用的是python2，版本为2.7.6。
\end_layout

\end_inset

编写，为跨平台提供了很好的支持。另外，目前适合python的科学计算库有Numpy和Scipy，但是其没有很好地提供稀疏向量的支持，因此，TinyRec内部还实
现了一个稀疏向量的运算库。
\end_layout

\begin_layout Section
系统功能模块划分 
\begin_inset CommandInset label
LatexCommand label
name "sec:系统功能模块划分"

\end_inset


\end_layout

\begin_layout Standard
TinyRec按照功能的需求的要求可以分成如下模块：数据预处理模块，参数配置模块，推荐算法模块，数据存储模块以及精确度测量模块。如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:系统总功能模块图"

\end_inset

所示。
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename 系统功能模块图.eps
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:系统总功能模块图"

\end_inset

系统总功能模块图
\end_layout

\end_inset


\end_layout

\end_inset

数据预处理模块负责执行推荐算法之前的数据处理。可用的数据集在使用之前必须要分割成训练集和测试集合，数据分割模块提供了对一个原始数据集分割的功能，将按照要求分割后
输出训练集合和测试集，一遍于后边算法精确度的测量。数据导入模块是将以文件形式的数据记录集合结构化，数据执行导入之后将会被按照数据存储模块提供的功能存放，可以是数
据库存储方式，直接内存存储方式，或者文件的存储方式。方便后边执行推荐算法以及精确度测量时候使用。
\end_layout

\begin_layout Standard
推荐算法模块是TinyRec最核心的功能。它可以针对结构化的数据记录进行关联挖掘。在基于用户和基于物品的推荐算法中，它负责的功能就是用户之间、物品之间的相似度计
算。评分预测模块就是根据获取到的这些关联，来进行预测工作。评分预测模块就是根据要求来给出特定用户对特定物品的评分。
\end_layout

\begin_layout Standard
精确度测量模块负责把测试数据集应用于精确度计算推荐算法模块所生成的预测模型中，通过预测模型给出的预测结果和训练集数据比较来计算精确度。精确度计算模块为提供具体的
精确度计算方法，本文实现了RMSE和MAE这两种方法。交叉验证模块提供交叉验证的功能，它与精确度计算模块共同提供衡量算法精确度的功能。
\end_layout

\begin_layout Section
系统体系结构设计
\begin_inset CommandInset label
LatexCommand label
name "sec:系统体系结构设计"

\end_inset


\end_layout

\begin_layout Standard
TinyRec的系统架构如图
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:TinyRec的系统架构图"

\end_inset

所示。TinyRec每个模块被打包成python包，以方便独立使用。TinyeRec在与数据存储通信是通过DAO层，各个模块只要调用其提供的API即可传输数据而
不用考虑具体实现。最初数据集由数据导入模块通过DAO层导入数据库中或内存中，目前TinyRec使用Redis数据库。其中各个模块直接并不直接联系，计算得到的必须
提供给其他模块的中间数据一般都放在数据库中，其他模块再自己获取。比如数据导入模块将数据结构化存入Redis中，然后相似度计算模块再从中获取每一条记录。图中每个模
块的参数配置都从参数配置模块中获取。推荐算法可以自由地在基于用户和基于物品算法中选取，这些也可以通过配置模块来修改。评分预测模块输出的预测结果可以用于计算算法的
精确度量。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename 系统架构图.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:TinyRec的系统架构图"

\end_inset

TinyRec的系统架构图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
功能模块的设计与实现
\begin_inset CommandInset label
LatexCommand label
name "sec:功能模块的设计与实现"

\end_inset


\end_layout

\begin_layout Subsection
数据预处理模块 
\end_layout

\begin_layout Subsubsection
数据分割
\end_layout

\begin_layout Standard
在使用数据集之前，必须先将原始数据集进行分割为训练集和测试集。数据集一般储存为文本文件，每一行代表一个记录：用户对物品的一次评分，数据预处理模块的目的就是提取每
一条记录结构化为(userid,itemid,rate)的元组，分别表示为用户的id，物品的id和物品的评分，本文接下去也使用这种表述。从数据库设计角度来看us
erid,itemid是主键，也就是一个用户给一个物品只能有一条评分。
\end_layout

\begin_layout Standard
考虑到交叉验证的需求，如果使用K-fold交叉验证，那么经过风格后将产生
\begin_inset Formula $K$
\end_inset

个训练集和测试集对，其中训练集合和测试记录的比例为
\begin_inset Formula $K-1:K$
\end_inset

。可以直接将用户的平分为K份。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:交叉验证与数据分割"

\end_inset

描述到分割数据时候，尽量为每个用户分割到足够的训练样矩阵本，这样才能有足够的信息产生推荐。因此为了方便让每个用户的数据足够，首先将对数据集中的每个记录按照use
rid排序，每K条进行一次随机排列，放入
\begin_inset Formula $K$
\end_inset

个缓冲区。最后在合并其中
\begin_inset Formula $K-1$
\end_inset

个缓冲区作为一个训练集，剩下一个作为测试集合。以下为python代码:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def split(infile, outdir, k_fo):
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    infile: file to be split
\end_layout

\begin_layout Plain Layout

    outdir: output file directory
\end_layout

\begin_layout Plain Layout

    k_fo: the number for k fold cross validation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    this funtion will generate k paris of trains and testing data
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    readfile = open(infile,'r')
\end_layout

\begin_layout Plain Layout

    #create k test files
\end_layout

\begin_layout Plain Layout

    test_files = []
\end_layout

\begin_layout Plain Layout

    for i in range(k_fo):
\end_layout

\begin_layout Plain Layout

        test_files.append(StringIO.StringIO())
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

    #split and write into to k stringIO buffer
\end_layout

\begin_layout Plain Layout

    count = 0 
\end_layout

\begin_layout Plain Layout

    rating_list_for_a_user = []
\end_layout

\begin_layout Plain Layout

    while True:
\end_layout

\begin_layout Plain Layout

        line = readfile.readline()
\end_layout

\begin_layout Plain Layout

        if not line :
\end_layout

\begin_layout Plain Layout

            append_to_stringIO(test_files, rating_list_for_a_user)
\end_layout

\begin_layout Plain Layout

            break
\end_layout

\begin_layout Plain Layout

        if count % k_fo == 0:
\end_layout

\begin_layout Plain Layout

            append_to_stringIO(test_files, rating_list_for_a_user)
\end_layout

\begin_layout Plain Layout

            rating_list_for_a_user = []
\end_layout

\begin_layout Plain Layout

            rating_for_a_user.append(line)
\end_layout

\begin_layout Plain Layout

        count += 1
\end_layout

\begin_layout Plain Layout

    readfile.close()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #generate k train and test file pairs
\end_layout

\begin_layout Plain Layout

    for i in range(k_fo):
\end_layout

\begin_layout Plain Layout

        with open("%s/train_%d.dat"%(outdir,i),"w") as f:
\end_layout

\begin_layout Plain Layout

            for j in range(k_fo):
\end_layout

\begin_layout Plain Layout

                test_files[j].seek(0)
\end_layout

\begin_layout Plain Layout

                if j != i:  #write to file
\end_layout

\begin_layout Plain Layout

                    for line in test_files[j]:
\end_layout

\begin_layout Plain Layout

                        f.write(line)
\end_layout

\begin_layout Plain Layout

        with open("%s/test_%d.dat"%(outdir,i),"w") as f:
\end_layout

\begin_layout Plain Layout

            for line in test_files[i]:
\end_layout

\begin_layout Plain Layout

                f.write(line)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    for f in test_files:
\end_layout

\begin_layout Plain Layout

        f.close()
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
其中第9行读入数据集，19行获取一个记录（即数据文件中的一行），21、24行的append_to_stringIO函数实现的功能是将长度为
\begin_inset Formula $K$
\end_inset

的列表重新随机排列后附在缓冲区的尾部。31～40的代码用于生成所需的测试集和数据集。
\end_layout

\begin_layout Subsubsection
数据导入
\end_layout

\begin_layout Standard
数据导入模块提供了从数据文件获取记录并且结构化的功能。如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:数据读取类图"

\end_inset

所示，Reader类接收数据文件路径（filepath）、评分记录模式（pattern)。评分记录模式是告诉Reader每一条记录是以什么结构在文本文件中组织的
。Reader可以通过getIterator方法来获取一个迭代器。类Iterator提供了三个方法get_all，get_next，以及get_net_dict
用来获取评分记录，他们分别返回记录列表，记录对象和以python字典格式的评分记录。在读取记录时，可以循环调用get_next等方法来获取，当记录读取完毕时，返
回None。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 数据导入类图.eps
	width 30col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:数据读取类图"

\end_inset

数据读取类图
\end_layout

\end_inset


\end_layout

\end_inset

下边的代码是一个使用Reader类将数据导入至Redis的例子：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

reader = Reader(data_path,data_sp,data_ptn)
\end_layout

\begin_layout Plain Layout

it = reader.get_iterator()
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

    record = it.get_next_dict()
\end_layout

\begin_layout Plain Layout

    if record == None:
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

    to_Redis(record)矩阵
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Data from %s imported to redis." % data_path
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
DAO模块
\begin_inset CommandInset label
LatexCommand label
name "sub:DAO模块"

\end_inset


\end_layout

\begin_layout Standard
DAO模块定义了存取或者获取数据的API，根据本推荐引擎TinyRec的需求，设计了如下API：
\end_layout

\begin_layout Standard
put_a_record(userid, itemid,rating)
\end_layout

\begin_layout Standard
存入具有userid的用户为具有itemid的物品给出评分rating的一条记录，即存入元组(userid,itemid,rating)。
\end_layout

\begin_layout Standard
get_item_list_by_user(userid)
\end_layout

\begin_layout Standard
通过userid获取用户他所有的评分记录，对应于用户
\begin_inset Formula $u$
\end_inset

评价的所有物品集合
\begin_inset Formula $I_{u}$
\end_inset

。该函数返回一组列表，列表里的每个元素是一个元组(itemid,rating),表示用户为具有itemid的物品的一条评分记录。
\end_layout

\begin_layout Standard
get_user_list_by_item(itemid)
\end_layout

\begin_layout Standard
通过itemid获取这个物品的得到的所有评分记录，对应于给物品
\begin_inset Formula $i$
\end_inset

评价的所有用户集合
\begin_inset Formula $U_{i}$
\end_inset

。该函数返回一组列表，列表里的每个元素是一个元组(userid,rating),表示具有userid的用户给其的一条评分记录。
\end_layout

\begin_layout Standard
get_rate(userid,itemid)
\end_layout

\begin_layout Standard
返回具有userid的用户给具有itemid的物品的一条评分记录，如果这条记录不存在，即用户未能给这个物品评分那么返回None。
\end_layout

\begin_layout Standard
get_user_rating_num(userid)
\end_layout

\begin_layout Standard
返回具有userid的用户评价的物品数量，即
\begin_inset Formula $\left|I_{u}\right|$
\end_inset

。
\end_layout

\begin_layout Standard
get_item_rating_num(userid)
\end_layout

\begin_layout Standard
返回具有itemid的物品得到用户的评价的数量,即
\begin_inset Formula $\left|U_{i}\right|$
\end_inset

。
\end_layout

\begin_layout Standard
put_item_sim(itemid,otheritemid,sim)
\end_layout

\begin_layout Standard
存入具有itemid的物品与具有otheritemid物品的相似度。
\end_layout

\begin_layout Standard
get_item_sim_list(itemid,k,bydesc)
\end_layout

\begin_layout Standard
返回与具有itemid最相似的前k个物品的列表，列表每个元素是一个元组(otheritemid,sim)，分别表示某个具有otheritemid的物品与当前物品
的相似度sim。bydesc表示是否按照相似度从大到小排列。
\end_layout

\begin_layout Standard
get_sim_between_two_items(itemid,otheritemid)
\end_layout

\begin_layout Standard
返回itemid与otheritemid的相似度
\end_layout

\begin_layout Standard
put_user_sim(userid,otheruser,sim)
\end_layout

\begin_layout Standard
存入具有userid的用户与具有otheruser的用户之间的相似度。
\end_layout

\begin_layout Standard
get_user_sim_list(userid,k,bydesc )
\end_layout

\begin_layout Standard
返回与具有userid最相似的前k个用户的列表，列表每个元素是一个元组(otheruser,sim)，分别表示某个具有otheruserid的用户与当前用户的相
似度sim。bydesc表示是否按照相似度从大到小排列。
\end_layout

\begin_layout Standard
get_sim_between_two_users(userid,otheritemid)
\end_layout

\begin_layout Standard
返回userid与otheruserid的相似度
\end_layout

\begin_layout Standard
get_user_rating_mean(userid)
\end_layout

\begin_layout Standard
返回用户的平均评分，即
\begin_inset Formula $\overline{r_{u}}$
\end_inset

。
\end_layout

\begin_layout Standard
get_item_rating_mean(item)
\end_layout

\begin_layout Standard
返回物品的平均评分，即
\begin_inset Formula $\overline{r_{i}}$
\end_inset

。
\end_layout

\begin_layout Standard
由于使用的是python语言，上述函数返回的数据结构，如列表、元组均为python提供的数据结构。
\end_layout

\begin_layout Subsection
数据存储模块
\end_layout

\begin_layout Standard
本模块即通过DAO模块存储数据用于为TinyRec提供临时或者永久的数据存储功能。在整个执行推荐的流程中，它需要存储基本的数据记录，计算得出的相似度等。Tiny
Rec支持使用内存数据库，关系数据库或者Nosql数据库等。根据推荐引擎的特点，不难得出数据存储必须满足下列要求：
\end_layout

\begin_layout Enumerate
由于计算相似度的需要，TinyRec需要从从数据存储处快速获取一条或者多条用户的评分记录，计算完毕之后将相似度存入。因此应当尽量保证低延迟，减少不必要的系统调用
与IO时间，让计算机CPU资源得到充分利用。
\end_layout

\begin_layout Enumerate
需要被存储的数据有不同的特点，比如某个物品的相似度存储需要按照大小有序排列，但是也要能够快速获取两个物品、两个用户之间的相似度。而用户与物品的评分记录可以无序存
放。
\end_layout

\begin_layout Standard
其中内存数据库相对于传统的关系数据库显然拥有更低的延迟与吞吐量，而支持SQL的关系数据库可以很容易地满足第二点要求。另外，本文使用的数据集较小，可以放入内存计算
。综合考虑，本文采用基于内存的，提供数据持久化功能的开源数据库Redis。Redis提供了许多数据结构，非常方便用户使用。根据不同数据的特点，本文如下设计数据的
存储结构：
\end_layout

\begin_layout Enumerate
评分记录的存储。首先，为每个用户建立一个hashset
\begin_inset Foot
status open

\begin_layout Plain Layout
本章节提到的数据结构均为Redis提供的数据结构
\end_layout

\end_inset

，用于存储该用户的评分记录。该hashset由用户id唯一标识，hashset内部存储(itemid,rating)的key-value对。在使用时，Redis
可以在
\begin_inset Formula $O(1)$
\end_inset

时间内根据给定用户id以及物品id获得或者存入对应的评分，也可以在
\begin_inset Formula $O(\left|I_{u}\right|)$
\end_inset

时间内获取用户评分的所有评分记录。为了方便地获取某个物品得到的评分记录，也为每个物品建立一个hashset，由物品id唯一标识，存储(userid,rating
)的评分记录，类似的Redis可以在
\begin_inset Formula $O(\left|U_{i}\right|)$
\end_inset

时间内获取该物品的得到用户的所有评分记录。
\end_layout

\begin_layout Enumerate
相似度的存储。为每个用户建立一个sorted set，存储(userid,sim)的key-value对，sim表示该用户与其他某个用户的相似度。为了节省空间的
需要，我们可以只存储与该用户最相似的前
\begin_inset Formula $K$
\end_inset

个用户，
\begin_inset Formula $K$
\end_inset

值大叫其实就是邻域的大小。Redis可以在
\begin_inset Formula $O(logK)$
\end_inset

时间内插入一条相似度记录，在
\begin_inset Formula $O(K)$
\end_inset

时间内取出按照相似度大小排列的一组用户列表，而根据两个用户id获取相似度只要
\begin_inset Formula $O(1)$
\end_inset

的时间。同样的我们也为每个物品建立相似的表，这里就不再赘述。
\end_layout

\begin_layout Subsection
参数配置模块 
\end_layout

\begin_layout Standard
参数配置模块接收用户的配置为输入，并为其他模块提供所需的参数，让其他模块根据设置类自动调整配置。所有的配置均存放在configure文本文件中，采用同用的ini
格式
\begin_inset CommandInset citation
LatexCommand cite
key "INI_filewiki"

\end_inset

，部分配置内容如下：
\end_layout

\begin_layout Standard
[global]
\end_layout

\begin_layout Standard
storage = redis 	;The place where data are stored.
\end_layout

\begin_layout Standard
multithread = auto 	;Enable multi-thread optimization.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
[collaborative filtering] 
\end_layout

\begin_layout Standard
model = user-based 	；Using user-based model
\end_layout

\begin_layout Standard
similarity = pearson 	;Chosing similarity
\end_layout

\begin_layout Standard
significance_weight = 80 ;Threshold for the significance weighting
\end_layout

\begin_layout Standard
neighborsize_K = 140
\end_layout

\begin_layout Standard
参数配置模块类图见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:类Config"

\end_inset

。为了使配置文件只被读一次以及配置参数只在内存中保存一份，对类Config使用单例模式，保证全局中只有一个Config的实例。类的初始化参数是配置文件的路径，在
初始化时读取参数配置并且将其以字典的形式保存。validater方法用于验证配置文件各个属性的有效性质。由于参数在运行时候可能改变，因此需要其他模块实现回调函数
来更新模块内部的参数，其他模块通过调用register()将回调函数注册，方便调用apply_changes()更新配置时候模块内部参数也得到更新。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 配置模块类图.eps
	scale 30

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:类Config"

\end_inset

类Config
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
相似度模块
\begin_inset CommandInset label
LatexCommand label
name "sub:相似度模块"

\end_inset


\end_layout

\begin_layout Standard
本模块计算用户之间或者物品之间的相似度。本模块可以看作一个相似度计算的过程，首先通过DAO获取用户的评分记录，再利用稀疏向量库来计算相似度，最终将数据保存用于接
下来的预测。相似度模块时序图见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:相似度模块时序图"

\end_inset

，过程All_similarity计算所有个体之间的相似度，调用K_nearest获取某个体的邻域，也就是最相似的K个个体。TwoSimilarity计算给定两
个个体之间的相似度，SparseVector是稀疏向量库给出的类，SimilarityAlgorithm则是章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

描述的相似度计算方法之一。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 相似度模块时序图.eps
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:相似度模块时序图"

\end_inset

相似度模块时序图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
模块在调用All_similarity之前，会从配置模块中获取配置来决定使用的算法，使用基于物品的或者是基于用户的，使用何种相似度方法等，以及其他算法有关参数，
如邻域K值大小。下边代码给出了算法选择和参数选择的逻辑：
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def get_config_and_set():
\end_layout

\begin_layout Plain Layout

    model = Config().configdict['collaborative_filtering']['model']
\end_layout

\begin_layout Plain Layout

    #item-based or user-based
\end_layout

\begin_layout Plain Layout

    if model == "user-based":
\end_layout

\begin_layout Plain Layout

        all_simlarity = all_user_similarity
\end_layout

\begin_layout Plain Layout

    elif model == "item-based":
\end_layout

\begin_layout Plain Layout

        all_simlarity = all_item_similarity
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        raise Exception("You should never get here, badly configed.")
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
过程TwoSimilarity将两个个体的评分记录转化为稀疏向量，即SparseVector的实例，再使用SimilarityAlgorithm获得两个向量之间
的相关度，即个体之间的相似度。在获得相似度之后，还需要根据算法选择的情况对相似度做一些修正，比如使用章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:重要性权重（Significance-Weighting）"

\end_inset

描述的重要性权重对交集过小的两个个体进行惩罚。K_nearest过程寻找给定的个体的邻域，方法是分别调用TwoSimilarit计算给定个体与其他个体的相似度，
保存结果排序并筛选出前K个个体返回。
\end_layout

\begin_layout Subsection
预测模块 
\end_layout

\begin_layout Standard
预测模块的使用前要求个体之间的相似度已经被计算完毕，本模块相对来说比较简单，类似于相似度模块，也可以看作是一个过程，具体流程见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:预测模块流程"

\end_inset

。其中最主要的是评分预测算法，TinyRec中采用的是章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:用K邻近算法预测"

\end_inset

中的算法，其实现见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:knn预测"

\end_inset

。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 预测模块流程图.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:预测模块流程"

\end_inset

预测模块流程图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
预测模块选择算法和设置参数的方式与相似度模块相同：从参数模块获取并设置。以基于用户的协同过滤算法为例，预测模块 通过DAO获取给定用户的邻域，调用API：get
_user_sim_list（见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:DAO模块"

\end_inset

）。返回的邻域被表示为按照相似度从大到小排列的一组列表，表内每一项为其他用户的id与相似度值，这些都作为给出预测的依据。预测模块对外提供predict_rate
_by_user_and_item接口，可供其他模块如精确度测量模块使用，其定义如下:
\end_layout

\begin_layout Standard
predict_rate_by_user_and_item(userid,itemid)
\end_layout

\begin_layout Standard
函数返回的对于具有userid的用户对具有itemid的物品的预测，如果用户已经为其评过分，则抛出异常。
\end_layout

\begin_layout Subsection
精确度测量模块 
\end_layout

\begin_layout Subsubsection
精确度计算
\end_layout

\begin_layout Standard
精确度计算旨在给定数据集合计算预测算法的精确度，其相关的主要类为Accuracy。见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:精确度计算相关类图"

\end_inset

。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 精确度模块.eps
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:精确度计算相关类图"

\end_inset

精确度计算相关类图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Accuracy类初始化为测试数据集的路径，通常测试数据集由数据导入模块中的数据分割工具产生。Accuracy类依赖与其他两个模块中的类，数据模块中的Reade
r和评分预测模块中的Predictor，类图中只显示Accuracy调用他们的方法。类Accuracy调用Reader的get_next来读取测试数据集中的一条
评分记录，这条记录给出了某个用户对某个物品的一次评分，Accuracy内部方法get_bias就是要把这个记录的评分作为真实值与预测值比较，得到偏差。要获取预测
值，get_bias内部调用了Predictor中的predict_rate_by_user_and_item方法来获取预测值。没一条记录的偏差将会被保存用于计
算精确度，目前TinyRec实现的度量方法有MAE与RMSE，具体实现见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:精确度评估"

\end_inset


\end_layout

\begin_layout Subsubsection
交叉验证
\begin_inset CommandInset label
LatexCommand label
name "sub:交叉验证模块"

\end_inset


\end_layout

\begin_layout Standard
交叉验证的相关类图见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:交叉验证相关类图"

\end_inset

。CrossValidate类的初始化参数为datasetpath，是原始数据的路径。CrossValidate类需要依赖数据导入模块中的数据分割工具来对原始数
据进行分割，还依赖于相似度模块（图中的Similarity包）和计算精确度的Accuracy类。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 精确度模块.eps
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:交叉验证相关类图"

\end_inset

交叉验证相关类图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
如章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:交叉验证与数据分割"

\end_inset

描述，使用k-fold方法的交叉验证需要对原有数据集合做k次的分割，然后进行k次的验证，也就是说要经过k次的计算相似度->计算精确度这一过程。虽然个体两两之间的
相似度可以只计算一次，然后k次分别选择在特定测试数据集中的邻域，但是这样得在相似度模块中作出修改，增加模块直接的耦合性，违背原有模块设计的初衷，而且为了简单起见
，CrossValidate将会k次调调用Similarity模块计算相似度再计算精确度。具体的k-fold交叉验证实现见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:交叉验证"

\end_inset


\end_layout

\begin_layout Section
算法设计与实现 
\begin_inset CommandInset label
LatexCommand label
name "sec:算法设计与实现"

\end_inset


\end_layout

\begin_layout Subsection
稀疏向量运算库
\end_layout

\begin_layout Standard
协同过滤的一个重要特征就是用户-物品矩阵非常地稀疏，对于一个用户往往只评价了物品空间中的一个很小的一部分，在计算相似度时候，基于用户的协同过滤和基于物品的协同过
滤分别需要把用户评分记录和物品得到的评分记录转换成向量的形式，以便计算两个向量之间的相关性，作为用户之间或者物品之间的相似度。由于转化成的向量十分稀疏，只有很小
一部分的项有有效值，所以用普通的向量计算方式将会十分耗费空间和时间。注意到，将用户评分记录和物品评分记录转换为向量时，以基于用户的协同过滤为例，把用户没有参与过
评分的物品对应的那一项设置为零，这里用到了默认评分方法
\begin_inset CommandInset citation
LatexCommand cite
key "39360168"

\end_inset

，这种方法对与cosine关联度没有影响，但是对于pearson和spearman方法会更好地体现用户之间的相似度（共同评分的项越小，他们越不相似），本文接下来
都将使用这种方法。由于python目前还没有比较好的稀疏向量运算的库，本文也用python设计并实现了一个稀疏向量运算库，打包成python包。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 悉数向量.eps
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:系数向量类SparseVector类图"

\end_inset

稀疏向量类SparseVector类图
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:系数向量类SparseVector类图"

\end_inset

为稀疏向量库的稀疏向量类SparseVector的类图，从图中我们可以看出，类SparseVector有两个成员变量：vector_list和vector_le
ngth。vector_length表示这个稀疏向量的长度，在基于用户的协同过滤算法中，这个长度的值也就是物品空间的大小，即总物品数。而vector_list则
是稀疏向量存储方式的关键。vector_list是一个列表，表中的项为一个元组
\begin_inset Formula $(index,value)$
\end_inset

，表示为该向量在index下标处有值value，没有表示的其他值为0。如向量(2,0,5,3,0,6)
\begin_inset Foot
status open

\begin_layout Plain Layout
下标从1开始，下同
\end_layout

\end_inset

可以存储如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:悉数向量表示"

\end_inset

的方式。这种实现方式类似于稀疏矩阵的一种存储方式。python数据结构list的实现方式其实是个数组，相对与用链表存储的方式，对于稀疏向量不容易添加新的非零项，
但是更具我们的需求出发，用户向量或者物品向量一般在计算相似度过程中将不会改变，方便起见，就使用python自带的数据结构list。 
\end_layout

\begin_layout Standard
稀疏向量的类在初始化时，接受三个参数：indices,values,vector_len。其中vector_len表示该限量的长度，将会被存在内部成员vecto
r_length中。indices，values为两个等长的列表，indices表示该向量的下标列表，值列表，两个列表的每一项一一对应。如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:悉数向量表示"

\end_inset

中的向量在初始化时传入的这两个列表可以分别是[1,3,4,6]和[2,5,3,4]。下列代码给出了初始化的实现方式：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

class SparseVector:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __init__(self, indices, values, vector_len):
\end_layout

\begin_layout Plain Layout

        self.vector_list = []
\end_layout

\begin_layout Plain Layout

        self.vector_length = vector_len
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if len(indices) != len(values):
\end_layout

\begin_layout Plain Layout

            raise ValueError("Tow list length do not match.")
\end_layout

\begin_layout Plain Layout

        for i in range(len(indices)):
\end_layout

\begin_layout Plain Layout

            if indices[i] > vec_len:
\end_layout

\begin_layout Plain Layout

                raise ValueError("Index exceed the vector length.")
\end_layout

\begin_layout Plain Layout

            self.vector_list.append((indices[i],values[i]))
\end_layout

\begin_layout Plain Layout

        vl = self.vector_list
\end_layout

\begin_layout Plain Layout

        vl.sort(key = lambda vl:vl[0])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
其中代码第3行的__init__方法就是python中的构造函数。第4行初始化vector_list为一个空的列表。第12行将indices，values中的项
一一对应，追加到vector_list中。第13～14行将vector_list中的项按照下标排序，以便进行后续的向量运算。向量的运算主要有加法和点乘运算，其思
路类似于归并排序的归并过程
\begin_inset CommandInset citation
LatexCommand cite
key "katajainen1996practical"

\end_inset

：对两个vector_list已经按照下标排好序的稀疏向量，将vector_list看作队列，若队列首部项大小不等，则小的那个项出队，否则进行一次运算后出队。下
列代码给出了稀疏向量点乘的一个例子：
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def multiply(sparsevector_a,sparsevector_b):
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    product = 0.
\end_layout

\begin_layout Plain Layout

    i,j = 0,0
\end_layout

\begin_layout Plain Layout

    while i < len(sparsevector_a.vector_list) and j < len(sparsevector_b.vector_li
st):
\end_layout

\begin_layout Plain Layout

        index_x, value_x = sparsevector_a.vector_list[i]
\end_layout

\begin_layout Plain Layout

        index_y, value_y = sparsevector_b.vector_list[j]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if index_x > index_y:
\end_layout

\begin_layout Plain Layout

            j += 1
\end_layout

\begin_layout Plain Layout

        elif index_x < index_y:
\end_layout

\begin_layout Plain Layout

            i += 1
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            dot_product += value_x * value_y
\end_layout

\begin_layout Plain Layout

            i += 1
\end_layout

\begin_layout Plain Layout

            j += 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   return dot_product
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 稀疏向量例子.eps
	width 90col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:悉数向量表示"

\end_inset

稀疏向量的存储方式
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
相似度度量 
\end_layout

\begin_layout Standard
我们可以利用已实现好的稀疏向量库来计算向量之间的相关性，即在推荐过程中个体之间的相似度。虽然稀疏向量库给出了一些基本的运算方法，但是不同相似度方法可能需要对每一
项进行不同的处理，因此，在实现向量相似度时，有些地方必须直接对稀疏向量中的非零项进行操作。
\end_layout

\begin_layout Subsubsection
cos相关系数 
\begin_inset CommandInset label
LatexCommand label
name "sub:cos"

\end_inset


\end_layout

\begin_layout Standard
根据式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度"

\end_inset

，其实现代码如下：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def cosine_corelation(sparsevector_a,sparsevector_b):
\end_layout

\begin_layout Plain Layout

    if sparsevector_a.vector_length != sparsevector_b.vector_length:
\end_layout

\begin_layout Plain Layout

        raise ValueError("Different vector length.")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    sv_a_m = math.sqrt(sum([v * v for (i,v) in sparsevector_a.vector_list]))
\end_layout

\begin_layout Plain Layout

    sv_b_m = math.sqrt(sum([v * v for (i,v) in sparsevector_b.vector_list]))
\end_layout

\begin_layout Plain Layout

    dot_product = multiply(sparsevector_a,sparsevector_b)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return dot_product / (sv_a_m * sv_b_m)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
首先，第2行判断两个向量是否有相同的长度。在计算两个向量直接的cosine相关度时，需要获得其模的大小，第5～6行分别计算两个向量的模。[v *
 v for (x,v) in sparsevector_a.
 vector_list]表示向量中所有非零值的平方作为列表，函数sum则对该列表进行求和，假设两个向量分别为 
\begin_inset Formula $\mathbf{x}$
\end_inset

，
\begin_inset Formula $\mathbf{y}$
\end_inset

，则此时已经得到
\begin_inset Formula $\mathbf{x^{2}}$
\end_inset

，
\begin_inset Formula $\mathbf{y^{2}}$
\end_inset

。在使用python自带的math包中的sprt函数分别对
\begin_inset Formula $\mathbf{x^{2}}$
\end_inset

，
\begin_inset Formula $\mathbf{y^{2}}$
\end_inset

开平方，得到所需的模。7行获取两个向量点乘结果，最终返回cosine相关度的值。
\end_layout

\begin_layout Standard
章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:均值中心化"

\end_inset

中对cosine相关度方法进行修正，本文的实现方法为在相似度模块中TwoSimilarity过程先对两个个体进行中心化处理，然后直接调用cosine_corel
ation进行计算，较为方便。中心化处理代码如下：
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def centralization(sparsevector):
\end_layout

\begin_layout Plain Layout

    vec_sum = sum([v for (i,v) in sparsevector.vector_list]) 
\end_layout

\begin_layout Plain Layout

	avg = vec_sum / len(sparsevector.vector_list)
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	for i in range(len(sparsevector.vector_list)):
\end_layout

\begin_layout Plain Layout

		sparsevector.vector_list[i][1] -= avg
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
第2～3行获取该向量非零值的平均值，以基于用户的协同过滤为例，该平均值即用户的平均打分。第5～6行表示对向量中每个非零项做减去平均值的中心化处理。注意到spar
sevector.vector_list[i][1]指的是vector_list中
\begin_inset Formula $(index,value)$
\end_inset

对的value值。
\end_layout

\begin_layout Standard
对于基于用户或者基于物品的不同协同方法，只需要正确地把用户评分记录或者物品得到的评分记录转化为SparseVector，再调用cosine_corelation
函数计算相似度，cosine_corelation并不需要知道悉数向量具体表示的是用户还是物品，因此不用对不同算法作出不同的实现。下述pearson相关系数，s
pearman相关系数都采用了这种设计方式。
\end_layout

\begin_layout Subsubsection
pearson相关系数 
\end_layout

\begin_layout Standard
我们可以直接使用章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:pearson相关系数"

\end_inset

中给出的式子来计算pearson相关系数 。本文使用另外一种更加易于实现的pearson 相关系数的形式，如式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pearson implemention"

\end_inset

，其中N为稀疏向量的长度：
\begin_inset Formula 
\begin{equation}
Pearson(x,y)=\frac{\sum_{i=1}^{N}x_{i}y_{i}-\frac{\sum_{i=1}^{N}x_{i}\sum_{i=1}^{N}y_{i}}{N}}{\sqrt{(\sum_{i=1}^{N}x_{i}^{2}-\frac{(\sum_{i=1}^{N}x_{i})^{2}}{N})(\sum_{i=1}^{N}y_{i}^{2}-\frac{(\sum_{i=1}^{N}y_{i})^{2}}{N})}}\label{eq:pearson implemention}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
使用式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pearson implemention"

\end_inset

我们很容易在归并过程中计算
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{i=1}^{N}x_{i}y_{i}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}x_{i}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}y_{i}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}x_{i}^{2}$
\end_inset

和
\begin_inset Formula $\sum_{i=1}^{N}y_{i}^{2}$
\end_inset

这五个值。下列代码给出了一个实现：
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def pearson_relation(sparsevector_a, sparsevector_b):
\end_layout

\begin_layout Plain Layout

    if sparsevector_a.vector_length != sparsevector_b.vector_length:
\end_layout

\begin_layout Plain Layout

        raise ValueError("Different vector length.")
\end_layout

\begin_layout Plain Layout

    size = sparsevector_a.vector_length
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Sum_x = 0.
\end_layout

\begin_layout Plain Layout

    Sum_y = 0.
\end_layout

\begin_layout Plain Layout

    Sum_xy = 0.
\end_layout

\begin_layout Plain Layout

    Sum_x2 = 0.
\end_layout

\begin_layout Plain Layout

    Sum_y2 = 0.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    i,j = 0,0
\end_layout

\begin_layout Plain Layout

    while i < len(sparsevector_a.vector_list) and j < len(sparsevector_b.vector_li
st):
\end_layout

\begin_layout Plain Layout

        index_x, value_x = sparsevector_a.vector_list[i]
\end_layout

\begin_layout Plain Layout

        index_y, value_y = sparsevector_b.vector_list[j]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if index_x > index_y:
\end_layout

\begin_layout Plain Layout

            Sum_y += value_y
\end_layout

\begin_layout Plain Layout

            Sum_y2 += value_y * value_y
\end_layout

\begin_layout Plain Layout

            j += 1
\end_layout

\begin_layout Plain Layout

        elif index_x < index_y:
\end_layout

\begin_layout Plain Layout

            Sum_x += value_x
\end_layout

\begin_layout Plain Layout

            Sum_x2 += value_x * value_x
\end_layout

\begin_layout Plain Layout

            i += 1
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            Sum_y += value_y
\end_layout

\begin_layout Plain Layout

            Sum_y2 += value_y * value_y
\end_layout

\begin_layout Plain Layout

            Sum_x += value_x
\end_layout

\begin_layout Plain Layout

            Sum_x2 += value_x * value_x
\end_layout

\begin_layout Plain Layout

            Sum_xy += value_x * value_y
\end_layout

\begin_layout Plain Layout

            i += 1
\end_layout

\begin_layout Plain Layout

            j += 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for it in range(i,len(sparsevector_a.vector_list)):
\end_layout

\begin_layout Plain Layout

        Sum_x += value_x
\end_layout

\begin_layout Plain Layout

        Sum_x2 += value_x * value_x
\end_layout

\begin_layout Plain Layout

    for it in range(j,len(sparsevector_b.vector_list)):
\end_layout

\begin_layout Plain Layout

        Sum_y += value_y
\end_layout

\begin_layout Plain Layout

        Sum_y2 += value_y * value_y
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    pearsonr = (Sum_xy - Sum_x * Sum_y / size) / 
\backslash

\end_layout

\begin_layout Plain Layout

            math.sqrt((Sum_x2 - Sum_x * Sum_x / size) * (Sum_y2 - Sum_y *
 Sum_y / size))
\end_layout

\begin_layout Plain Layout

    return pearsonr
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
在这段代码中
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{i=1}^{N}x_{i}y_{i}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}x_{i}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}y_{i}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}x_{i}^{2}$
\end_inset

，
\begin_inset Formula $\sum_{i=1}^{N}y_{i}^{2}$
\end_inset

，分别被表示为
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
Sum_xy，Sum_x，Sum_y，Sum_x2，Sum_y2这五个向量。在计算过程中，我们可以直接略过那些值为零的项，只计算非零项。如向量x有下标为i的项，
而y没有这个项，也就是y中对应下标的项为零，那么这个项只会影响到Sum_x，Sum_x2这两个变量，代码17～24行就是处理这种情况。代码第25～32行处理两个
向量共同具有的项的情况。代码34～39行处理其中一个向量先达到末尾的情况，最后根据式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:pearson implemention"

\end_inset

我们得出最终的pearson相关系数。
\end_layout

\begin_layout Subsubsection
spearman秩相关系数
\end_layout

\begin_layout Standard
通过章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:spearman秩相关系数"

\end_inset

我们知道，计算spearman最关键的步骤就是将向量中的每一项映射成秩，接着计算其pearson相关系数就简单了。将。
\begin_inset Formula $\mathbf{x}=(25,13,14,31,10,14,37,14)$
\end_inset

,将其每一项映射成秩的过程见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:向量编秩过程"

\end_inset

。首先，将向量每个项按照值的大小排序，得到如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:向量编秩过程"

\end_inset

中的第2个列表。接着，我们将该列表每一项编号为其在列表中的位置，见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:向量编秩过程"

\end_inset

中的第3个列表。最后，我们看到列表3中的3，4，5应相同的值：14，因此我们调整这个值对应的秩为这3，4，5的评价值
\begin_inset Formula $\frac{3+4+5}{3}=4$
\end_inset

，得到列表4。于是我们就可以得到将原始值映射成秩的对应列，见表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:每个值与秩的映射列表"

\end_inset

。因此，将向量
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{x}=(25,13,14,31,10,14,37,14)$
\end_inset

编秩的结果
\begin_inset Formula $rank_{x}=(6,2,4,7,1,4,8,4)$
\end_inset

。
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 编秩过程.eps
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:向量编秩过程"

\end_inset

向量编秩过程
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
原始值
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
秩
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:每个值与秩的映射列表"

\end_inset

每个值与秩的映射列表
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

综上所描述，几个步骤的目的是获得类似表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:每个值与秩的映射列表"

\end_inset

的对应关系，下列代码中的函数接受向量
\begin_inset Foot
status open

\begin_layout Plain Layout
该向量由python的list表示，并非稀疏向量
\end_layout

\end_inset

，并返回表示对应关系的字典rdict，rdict是一个(key,value)的hash表，其中的key表示原始值，value表示对应的秩。
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def get_rank_dict(vector):
\end_layout

\begin_layout Plain Layout

    v = vector[:]
\end_layout

\begin_layout Plain Layout

    v.sort()
\end_layout

\begin_layout Plain Layout

    v.append(None)#nothing equals to None
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    rank_l = range(1,len(v))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    k = 0
\end_layout

\begin_layout Plain Layout

    current = v[0]
\end_layout

\begin_layout Plain Layout

    for i in range(len(v)):
\end_layout

\begin_layout Plain Layout

        if current != v[i]:
\end_layout

\begin_layout Plain Layout

            set_avg(rank_l,k,i-1)
\end_layout

\begin_layout Plain Layout

            k = i
\end_layout

\begin_layout Plain Layout

            current = v[i]
\end_layout

\begin_layout Plain Layout

    rdict = {}
\end_layout

\begin_layout Plain Layout

    for i in range(len(v)-1):
\end_layout

\begin_layout Plain Layout

        rdict[str(v[i])] = rank_l[i]
\end_layout

\begin_layout Plain Layout

    eturn rdict
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def set_avg(l,start,end):
\end_layout

\begin_layout Plain Layout

    avg = (end + start)/2.0 + 1
\end_layout

\begin_layout Plain Layout

    for i in range(start,end +1):
\end_layout

\begin_layout Plain Layout

        l[i] = avg
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset

代码第2行将传入的vector复制一份用于后续的操作，防止原有的向量被修改。第3行将复制的向量v按照项的大小排序，即图
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:每个值与秩的映射列表"

\end_inset

中1～2的过程。第3行为了满足下边的循环的逻辑条件，在末尾添加一个值。第6行生成顺序的编号，对应图
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:每个值与秩的映射列表"

\end_inset

的列表3，从列表3到列表4我们修改具有相同值的项对应的秩。函数set_avg(l,start,end)将列表l中从start到end的秩设置为它们的平均值。对于
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:每个值与秩的映射列表"

\end_inset

第3个表中的3，4，5，set_avg将把它们设为4。8～4行遍历排序过的向量，k值记录第一个与之前值不同的项的下标，通过比较当前值v[i]与之前的值比较，来确
定set_avg中需要被设置为平均值的范围。最后5～7行生成表示对应关系的字典。
\end_layout

\begin_layout Subsubsection
重要性权重 
\end_layout

\begin_layout Standard
根据章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:重要性权重（Significance-Weighting）"

\end_inset

给出的公式，我们很容易计算两个个体之间的重要性权重。对相似度做重要性权重的修正在相似度模块的TwoSimilarity过程中执行，见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度模块"

\end_inset

。以基于物品的协同过滤算法为例，下面代码给出了其简化的实现：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def two_smilarity(usera,userb):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    sparseveca = to_sparse_vector(usera)
\end_layout

\begin_layout Plain Layout

    sparsevecb = to_sparse_vector(userb)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    sim = vector_correlation_algorithm(sparseveca,sparsevecb)
\end_layout

\begin_layout Plain Layout

    if significance_weight_enabled():
\end_layout

\begin_layout Plain Layout

       i = len(set([i for i,v in usera]) & set([i for i,v userb]))
\end_layout

\begin_layout Plain Layout

        if i < significance_weight:
\end_layout

\begin_layout Plain Layout

            sim *= float(i) / float(significance_weight)
\end_layout

\begin_layout Plain Layout

    return sim 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
two_smilarity函数计算两个用户的usera,userb的相似度，再使用重要性权重进行修正。在第6行获取了两个向量之间的关联度，即用户之间的相似度，第
8行计算两个用户共同评价的物品数即
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left|I_{a}\cap I_{b}\right|$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
。代码[i for i,v in usera]表示用户a的评分过物品列表，表内每一项为物品的id，再将这个列表转化为python自带的数据结构set，两个set
取交集后使用函数len获取其交集大小。最后再比较交集大小i是否符合需要修正的要求，如果小于significance_weight值那么相似度sim需要乘以
\begin_inset Formula $\frac{i}{significance\_weight}$
\end_inset

。交集大小可以用类似章节
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:类Config"

\end_inset

的归并两个列表的方式来实现，方便起见，给出的实现使用python内置的set结构，其实两者本质上没有区别。
\end_layout

\begin_layout Subsection
KNN预测 
\begin_inset CommandInset label
LatexCommand label
name "sub:knn预测"

\end_inset


\end_layout

\begin_layout Standard
本文实现采用均值中心化的KNN预测，见式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:基于用户的KNN-中心化"

\end_inset

。下面代码实现了基于用户的协同过滤算法的评分预测：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def user_based_predict_by_knn(userid,itemid):
\end_layout

\begin_layout Plain Layout

    mean = get_mean(userid)
\end_layout

\begin_layout Plain Layout

    sim_list = get_user_topk_neighbor(userid)
\end_layout

\begin_layout Plain Layout

    other_user_rate_list = []
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    for u,s in sim_list:
\end_layout

\begin_layout Plain Layout

        r = get_rate(u,itemid)  #get other users rate
\end_layout

\begin_layout Plain Layout

        if r:
\end_layout

\begin_layout Plain Layout

            other_user_rate_list.append((u,s,r)) #user, similarity, rate
\end_layout

\begin_layout Plain Layout

    if len(other_user_rate_list) == 0:  #no item in neighbor
\end_layout

\begin_layout Plain Layout

        return mean
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        sum1 = 0.
\end_layout

\begin_layout Plain Layout

        sum2 = 0.
\end_layout

\begin_layout Plain Layout

        for u,s,r in other_user_rate_list:
\end_layout

\begin_layout Plain Layout

            sum1 += s * (r - get_mean(u))
\end_layout

\begin_layout Plain Layout

            sum2 += s 
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        predict_rate = userbaseline + sum1 / sum2
\end_layout

\begin_layout Plain Layout

        return predict_rate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
该函数接收userid，itemid作为参数，提供为具有userid的用户对具有itemid的物品的评分预测。第2行获取该用户打分的平均值。第3行根据useri
d获取该用户的邻域，但是只获取邻域还不够，只有邻域中也为具有itemid的物品评过分的用户能作为评分预测的依据。第4行other_user_rate_list就
是用于存储邻域中也为具有itemid的物品评过分的用户，list中每一项为一个元组(uid,sim,rate)，分别表示邻域中可用用户的id，与被预测用户的相似
度，以及这个用户给目标物品的评分。6～9行中，遍历邻域中所有用户，找出为具有itemid的物品评过分的用户并存入other_user_rate_list中。第1
1行处理了邻域中没有用户为目标物品评分的情况，直接返回用户的平均评分，这也是唯一可以利用的信息。
\end_layout

\begin_layout Standard
第13～19行则是真正进行KNN来预测的过程。sum1表示式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:基于用户的KNN-中心化"

\end_inset

中的
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}(r_{v,i}-\overline{r_{v}})$
\end_inset

，
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
它每次循环都会加上s * (r - get_mean(u))，sum1则表示
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}$
\end_inset

，注意这里没有加上绝对值是因为本文不使用负相关的关联，所有与目标用户有负相似度的用户已经在函数get_user_topk_neighbor中过滤。19行得到最终
结果并返回。
\end_layout

\begin_layout Subsection
精确度评估
\begin_inset CommandInset label
LatexCommand label
name "sub:精确度评估"

\end_inset

与交叉验证
\begin_inset CommandInset label
LatexCommand label
name "sub:交叉验证"

\end_inset


\end_layout

\begin_layout Standard
由于RMSE和MAE在计算过程中很相似，它们可以一并来实现，下面代码给出了一个实现：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def RMSE_MAE(testfilepath,othersettings):
\end_layout

\begin_layout Plain Layout

    count = 0
\end_layout

\begin_layout Plain Layout

    totalbiassquare = 0.
\end_layout

\begin_layout Plain Layout

    totalbias = 0.
\end_layout

\begin_layout Plain Layout

    it = Reader(testfilepath,seperater,pattern_list).get_iterator()
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    while True:
\end_layout

\begin_layout Plain Layout

        record = it.get_next_dict()one_validate
\end_layout

\begin_layout Plain Layout

        if record == None:
\end_layout

\begin_layout Plain Layout

                break
\end_layout

\begin_layout Plain Layout

        predict_rate = predict_item_score(record.userid,record.itemid)
\end_layout

\begin_layout Plain Layout

        bias = predict_rate - record.rate
\end_layout

\begin_layout Plain Layout

        totalbias += abs(bias)
\end_layout

\begin_layout Plain Layout

        totalbiassquare += bias * bias
\end_layout

\begin_layout Plain Layout

        count += 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return math.sqrt(totalbiassquare / count), totalbias / count
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
其中变量count表示测试样本数，即
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:RMSE"

\end_inset

与式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:MAE"

\end_inset

中的
\begin_inset Formula $\left|Ts\right|$
\end_inset

，
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
totalbiassquare和totalbiass表示变差的平方和与偏差的绝对值和，对应
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:RMSE"

\end_inset

中的
\begin_inset Formula $\underset{u,i\in Ts}{\sum}(\hat{r}_{u,i}-r_{u,i})^{2}$
\end_inset

和
\begin_inset Formula $\underset{u,i\in Ts}{\sum}\left|\hat{r}_{u,i}-r_{u,i}\right|$
\end_inset

。第5行获取读取测试数据集的一个iterator。第11行调用
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
predict_item_score让推荐引擎TineyRec返回预测。
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
第12行
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
bias用来表示预测值与真实值之间的误差。最终17行分别返回计算出的RMSE与MAE的值。
\end_layout

\begin_layout Standard
章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:交叉验证模块"

\end_inset

描述了交叉验证的大致流程，下面代码给出了其简单的实现：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def one_validate(train_path,test_path):
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

    datatoredis(train_path) #read in file 
\end_layout

\begin_layout Plain Layout

    all_simlarity(train_path) 
\end_layout

\begin_layout Plain Layout

    rmse = RMSE(train_path)
\end_layout

\begin_layout Plain Layout

    return rmse
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def cross_validate(k):
\end_layout

\begin_layout Plain Layout

    datasetspliter.split(datafile_path,tofile_dir,k)
\end_layout

\begin_layout Plain Layout

    rmse_list = []
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    for i in range(k):
\end_layout

\begin_layout Plain Layout

        train_path = tofile_dir + "/train_%d.dat"%(i)
\end_layout

\begin_layout Plain Layout

        test_path = tofile_dir + "/test_%d.dat"%(i)
\end_layout

\begin_layout Plain Layout

        accu = one_validate(train_path,test_path)
\end_layout

\begin_layout Plain Layout

        rmse_list.append(accu)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    return sum(rmse_list)/len(rmse_list)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset

one_validate函数是执行一次数据导入、计算相似度、计算精确度的完整过程。第9行对原始数据集合做出一次切割，rmse_list用于存储每一次计算的RMS
E精确度。12～16行一共调用k次one_validate来得到每一次的精确度，最后18行返回平均值作为最终结果。
\end_layout

\begin_layout Subsection
并行化
\end_layout

\begin_layout Standard
为了充分利用计算机的CPU资源，本文对相似度模块进行了并行化处理。接下来以基于用户的协同过滤算法为例，介绍算法并行化的设计与实现。根据相似度模块中的工作，每一个
用户都将会与其他用户计算一次复杂度，而每个用户在计算时候，所需的数据为其他用户的评分记录（被转化成向量的形式），并且不修改其他用户的记录，计算完毕之后的相似度也
与其他用户的计算的相似度分别存储。综上，我们很容易地对相似度模块进行并行化处理而不用考虑太多的同步问题，如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:相似度模块并行化"

\end_inset

所示。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 并行化.eps
	width 90line%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:相似度模块并行化"

\end_inset

相似度模块并行化
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
根据图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:相似度模块并行化"

\end_inset

，我们将要计算用户id为1～80的用户之间的相似度
\begin_inset Foot
status open

\begin_layout Plain Layout
这里假设用户id是连续的，用户id的编号方式不影响最终结果
\end_layout

\end_inset

，我们首先对其进行分割，分割的数量根据需要而定，可以是cpu的逻辑核数。分割采用平均分割的方法，图中把80个用户平均分割成4份，每一份对其计算其中每个用户的的相
似度，这一过程可以被同时执行。在实现中，我们可以在all_similarity过程中进行这个工作，代码如下：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def all_similarity():
\end_layout

\begin_layout Plain Layout

    devide_number = multithread
\end_layout

\begin_layout Plain Layout

    start = 0 
\end_layout

\begin_layout Plain Layout

    total = maxuserid + 1 - start
\end_layout

\begin_layout Plain Layout

    proclist = []
\end_layout

\begin_layout Plain Layout

    for i in range(0,devide_number):
\end_layout

\begin_layout Plain Layout

        end = start + total / devide_number
\end_layout

\begin_layout Plain Layout

        if end > maxuserid or i == devide_number - 1:
\end_layout

\begin_layout Plain Layout

            end = maxuserid + 1
\end_layout

\begin_layout Plain Layout

        p = Process(target = user_similarity_in_range,args = (start,end))
\end_layout

\begin_layout Plain Layout

        proclist.append(p)
\end_layout

\begin_layout Plain Layout

        p.start()
\end_layout

\begin_layout Plain Layout

        start = end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for p in proclist:
\end_layout

\begin_layout Plain Layout

        p.join()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def user_similarity_in_range(start,end):
\end_layout

\begin_layout Plain Layout

   for userid in range(start,end):
\end_layout

\begin_layout Plain Layout

        similarity_to_others(userid) 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
在实现时，由于python线程包对cpu资源利用率有限，我们使用多进程的编程方式，为每个分割创建一个进程，如代码第5，10，15～16行：proclist用于保
存进程，6～9行用于分割数据，接着再传给各个进程。函数user_similarity_in_range则是对每个分割计算其中每个用户与其他用户的相似度。但是上述
实现隐藏了一个问题：多个进程很容易同时访问某个用户的评分记录导致性能下降，本文实现将这一问题推至给Redis，如果采用其他并发效率低的存储方式，可以在本地建立一
个缓存，还可以让每个进程错开在同一时间内访问相同用户的评分记录的方式，具体实现本文不再讨论。
\end_layout

\begin_layout Chapter
算法精确度实验 
\end_layout

\begin_layout Standard
为了比较不同算法的结果以及不同参数对算法精确性的影响，本文在TinyRec推荐引擎上应用了不同的算法来进行分析比较。
\end_layout

\begin_layout Section
实验数据与度量标准
\begin_inset CommandInset label
LatexCommand label
name "sec:实验数据与度量标准"

\end_inset


\end_layout

\begin_layout Standard
本文使用与文章
\begin_inset CommandInset citation
LatexCommand cite
key "124971"

\end_inset

中相同的数据集，MovieLens数据集。MovieLens是美国Minnesota大学计算机科学学院的GroupLens小组于1997年创办的一个非商业的电影
站点，用于科学研究。它每周有数以百计的用户访问网站并且为电影评分
\begin_inset CommandInset citation
LatexCommand cite
key "124971"

\end_inset

。目它对外公开了其数据集合，本文使用的数据集合是其中的100K的版本，即一共有十万条评分记录。这个数据集中一共有1682件物品，943个用户。其中每个用户都至少
为20个电影给出了评分。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename user_rating_frequency_data.jpeg
	width 60col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:单个用户评分数量直方图"

\end_inset

单个用户评分数量直方图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename item_rating_frequency_data.jpeg
	width 60col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:单个电影得到评分数量直方图"

\end_inset

单个电影得到评分数量直方图
\end_layout

\end_inset


\end_layout

\end_inset

通过对MovieLens数据集的分析，我们可以发现这么一个事实，大部分用户只对一小部分电影评分，而大部分电影只收到很少的用户的评分甚至没有评分。见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:单个用户评分数量直方图"

\end_inset

为单个用户评分数量直方图，图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:单个电影得到评分数量直方图"

\end_inset

为单个电影评分数量直方图。
\end_layout

\begin_layout Standard
章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:精确率度量方法"

\end_inset

给出了两种不同的精确度度量方法，两者都是通过比较实际值与预测值的误差来衡量误差：最终RMSE或者MAE的值越低则说明算法越准确。由于MAE被广泛使用并且能够很好
地用于解释和说明，本实验主要使用MAE的方法来度量预测结果的精确度。
\end_layout

\begin_layout Section
实验方法
\begin_inset CommandInset label
LatexCommand label
name "sec:实验方法"

\end_inset


\end_layout

\begin_layout Standard
本文接下来的实验采用交叉验证的方法，一般经验上来讲，交叉数目为5或者10，为了能有更多的信息来提供预测，本文采用10-fold的交叉方式。在预测过程中，在计算时
，对一个用户或者物品计算它与其他所有的用户或者物品的相似度，即每个其他的用户和物品都可能是该用户或者物品潜在的一个邻居，而不是使用抽样的方法，这样可以尽可能地利
用到所有数据，更好地体现各个算法的特点。为了更好的比较同算法的结果以及不同参数对算法精确性的影响，在进行完整的实验前，在完整数据集上探索了即将被实验的参数和算法
的较优值，所有的参数或者算法是在其他参数处于较优的情况下进行实验的。
\end_layout

\begin_layout Standard
本文的实验步骤是使用章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:交叉验证模块"

\end_inset

中描述的模块中的过程来进行的，其中关键步骤为：
\end_layout

\begin_layout Enumerate
数据分割：将数据集合随机分割成10份，这次分割的结果将用于接下来的全部实验，不再进行额外的重新分割过程。
\end_layout

\begin_layout Enumerate
数据导入：选择一个测试数据集和训练数据集对，将训练数据导入到推荐引擎TinyRec中。
\end_layout

\begin_layout Enumerate
计算相似度：在这个训练数据集中，计算两两之间的相似度。这里我们没有使用负相关的邻居。
\end_layout

\begin_layout Enumerate
计算精确度：利用步骤3计算的结果来预测测试数据集中的数据，比较结果并计算精确度
\end_layout

\begin_layout Enumerate
交叉验证：选择另一个测试数据集和训练数据集对，重复2～5过程，直到10对测试数据集和训练数据集对均被计算完毕，返回平均值作为一次实验的最终结果。
\end_layout

\begin_layout Standard
本实验使用的系统环境如下：
\end_layout

\begin_layout Enumerate
python解释器：PyPy 2.2.1 with GCC 4.8.2。PyPy是用Python实现的Python解释器，带有运行时编译功能，能够根据动态语言运行时的特
点进行优化。本文选择PyPy的原因是其优秀的执行效率，同等情况下实验运行时间大致为CPyhon的四分之一。
\end_layout

\begin_layout Enumerate
Linux x86_64操作系统，3.16.0内核版本。
\end_layout

\begin_layout Enumerate
Redis 3.0.1 64位版本：本实验使用Redis作为推荐引擎TinyRec的数据存储方式。
\end_layout

\begin_layout Standard
由于TinyRec目前是只支持单机计算，而且本文使用的数据集规模不大，所以采用PC机作为运行环境。本实验使用的硬件环境如下：
\end_layout

\begin_layout Standard
1.CPU：E3 1230V3@3.3GHz
\end_layout

\begin_layout Standard
2.内存：8GB
\end_layout

\begin_layout Standard
3.Intel 520 SSD 120G
\end_layout

\begin_layout Section
实验内容及结果
\begin_inset CommandInset label
LatexCommand label
name "sec:实验内容及结果"

\end_inset


\end_layout

\begin_layout Subsection
相似度方法 cos,spearman,pearson,pearson-with default rate 
\end_layout

\begin_layout Subsection
邻域大小的选择
\end_layout

\begin_layout Standard
在使用基于用户以及基于物品的协同过滤推荐算法中，邻域大小的选择对算法结果影响巨大，过于小的邻域将使得可用信息过少，过于依赖于最相似的用户，而过大的邻域将会导致计
算缓慢等问题。而目前选择领域大小也主要通过实验对比获得。在这个实验中，本文给出了不同邻域大小k值对准确度MAE的影响。本实验k取值范围为10～140相隔10的大
小计算一次精确度，一共14组数据，分别对Cosine相关系数，Pearson相关系数和Spearman秩相关系数这三个方法研究邻域大小对其精确度的影响。
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename k对精确度影响.eps
	width 80col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:邻域大小k对不同算法精确度的影响"

\end_inset

邻域大小k对不同算法精确度的影响
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:邻域大小k对不同算法精确度的影响"

\end_inset

为邻域大小k对不同算法精确度的影响。从图中我们可以看出Cosine相关系数，Pearson相关系数这两个相似度方法的折线非常接近，在k值从10～50范围内，MA
E随着k值增大下降明显，随后的MAE量一直稳定在0.742左右变化不大，而k值对于spearman秩相关系数方法在10～130区间内一直在下降，一开始spearm
an秩相关系数MAE误差相对其他两个方法较低，而随着k值的增加，和其他两个的MAE值越来越接近。不难发现，spearman秩相关系数更加依赖于大的邻区域。
\end_layout

\begin_layout Subsubsection
基于用户的协同过滤算法
\end_layout

\begin_layout Subsection
significance weighting 值选择 
\end_layout

\begin_layout Subsection
item-based vs user-based 
\end_layout

\begin_layout Chapter
总结与展望
\end_layout

\begin_layout Standard
本文主要给出了一个推荐引擎TinyRec的设计与实现，并且比较了不同算法的性能以及不同参数对算法结果的影响。进一步的的工作可以如下方面展开。
\end_layout

\begin_layout Enumerate
完善推荐算法。目前TinyRec只实现了基于协同过滤中基于用户以及基于物品的算法，用于产生评分预测。实现的算法较为简单，未来可以实现更多的协同过滤算法如SVD，
slope one等最近较为热门算法，不仅如此，还可以实现基于内容过滤，基于规则过滤等推荐方式，让TinyRec更加灵活，适应工程上的要求等等。
\end_layout

\begin_layout Enumerate
拓展TinyRec。目前TinyRec只是作为一个推荐引擎使用，离一个真正的推荐系统还有很大的距离，比如提供推荐结果解释。推荐解释是在提供推荐时候为用户解释推荐
的原因，使得推荐结果更加具有说服力，可以增大用户对推荐系统的信任程度。还应该能够提供最基本的TopN推荐，推荐应该着重于用户接受度，覆盖率，新颖度等指标，而不是
只追求精确度，毕竟最终目的是推荐而不是预测。
\end_layout

\begin_layout Enumerate
推荐质量与时实性的平衡。大多数的推荐算法计算相似的度比较高，对于不断增长的数据量，离线计算将会花费大量时间。为了能够在一定时间内向用户给出推荐，可以升级硬件设备
或者改进算法。比如用一些聚类的方法
\begin_inset CommandInset citation
LatexCommand cite
key "1284393,485233,295125"

\end_inset

降低搜索空间，但是对应的会损失一些精确度。如何在保证推荐质量同时有效地提高计算效率需要值得研究。
\end_layout

\begin_layout Enumerate
不同推荐算法的集成。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:生成推荐的方式"

\end_inset

中描述了几种不同的推荐方式，以及混合推荐的方式。通过混合推荐，能够弥补不同算法的缺点。未来可以对TinyRec实现这一功能，使之能够按照要求选择算法并集成推荐结
果。
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "seuthesis"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
