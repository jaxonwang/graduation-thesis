#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\begin_preamble
\usepackage{pythonhighlight}

\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman SimSun
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
绪论
\end_layout

\begin_layout Section
课题背景
\end_layout

\begin_layout Subsection
推荐系统介绍
\end_layout

\begin_layout Standard
互联网的普及让人类进入了信息时代，各种各样的信息唾手可得。根据粗略估计，互联网每日产生的数据量已经达到EB的级别。这么多的数据导致了信息过载，用户面对这样庞大的
数据，很难手动从中过滤掉无用的信息，筛选出有价值的信息。比如互联网电商，社交网站，新闻网站中，充斥着数以百万计的物品信息，对于用户来说，不可能完整地一一浏览过滤
。针对数据过载这一问题，信息检索、数据挖掘、预测推荐等技术得到了广泛的应用。
\end_layout

\begin_layout Standard
搜索引擎是信息检索技术的集大成者。当今世界上搜索引擎Google一家独大，用户可以通过向搜索引擎提供关键词来获得搜索结果。同时，搜索引擎也可以通过数据挖掘技术为
不同类别的信息分类或者提供标签。但是如果用户向搜索引擎提供的信息有限，甚至不知道什么才是自己所需要的，那么搜索引擎就不能很好地解决信息过载这一问题
\begin_inset CommandInset citation
LatexCommand cite
key "许海玲2009互联网推荐系统比较研究"

\end_inset

。此时就需要能根据用户的喜好与品味给用户提供合适推荐的推荐系统了。
\end_layout

\begin_layout Standard
推荐系统又叫个性化推荐系统
\begin_inset CommandInset citation
LatexCommand cite
key "2421220"

\end_inset

，是信息过滤系统的一个子集，它尝试预测用户可能对一个物品的“评分”和“喜好程度”
\begin_inset CommandInset citation
LatexCommand cite
key "39360168"

\end_inset

。相对于非个性化推荐结果，如搜索引擎返回的结果，个性化搜索引擎更加依赖与用户的行为数据。个性化推荐系统需要在大量的用户数据中挖掘用户与物品之间内在的关联性，根据
这些知识来为对用户进行推荐。推荐系统被证明是解决信息过载问题的一个有效工具，具体地来说，从用户的显式或者隐式信息中提取有效的部分，进行建模来分析用户的品味和喜好
，再把用户可能喜欢的物品进行排序，对用户进行个性化的推荐。
\end_layout

\begin_layout Standard
推荐系统广泛地应用于互联网各大网站。通过推荐系统，能够很好地抓住用户的口味，符合用户的个性，大大提高了用户的转化率，为企业带来巨大的利润。下边介绍几种典型的应用
领域。
\end_layout

\begin_layout Enumerate
电子商务 电子商务网站是推荐系统被广泛应用的一个领域之一。亚马逊是著名的电子网站，它把推荐系统应用到了极致,也是最早应用推荐系统的网站之一。它提出来名为item
-to-item的协同过滤算法
\begin_inset CommandInset citation
LatexCommand cite
key "861437"

\end_inset

，推动了推荐系统邻域的发展。为后来用户登录后，它在首页为用户提供了个性化推荐列表。其中在每一样商品下方提供了其他商品的推荐，这些商品往往是其他用户最可能同时购买
的，并对打包购买提供一定的折扣。
\end_layout

\begin_layout Enumerate
电影视频网站 在电影视频网站中，使用推荐系统能够帮助用户找到他们喜欢的视频。Youtube目前是全球最大的视频网站，拥有大量的用户数据已经大量的视频。Youtu
be通过应用推荐系统，大大增加了用户的视频点击率。根据实验，个性化推荐相对与非个性化推荐有两倍多点击率
\begin_inset CommandInset citation
LatexCommand cite
key "39238972"

\end_inset

。 
\end_layout

\begin_layout Enumerate
音乐网络电台 音乐网络电台为用户提供了音乐点播服务，如果能准确地向用户推荐他喜爱的音乐那么会极大地增加用户的黏度。国内一个著名的音乐电台是
\begin_inset CommandInset href
LatexCommand href
name "douban.fm"
target "douban.fm"

\end_inset

，它为用户提供对歌曲喜欢或者删除的接口，户收集用户对歌曲的反馈，从而提供准确的推荐。
\end_layout

\begin_layout Enumerate
社交网络 社交网络包含巨大的用户之间的社交信息。Facebook是社交网络的一个代表。它利用了用户的社交信息、偏好信息来推荐物品。Facebook对外提供了一个
推荐API，可给用户推荐其好友喜欢的物品。
\end_layout

\begin_layout Subsection
推荐系统的功能
\end_layout

\begin_layout Standard
Herlocker等人
\begin_inset CommandInset citation
LatexCommand cite
key "804401"

\end_inset

定义了一些推荐系统的主要任务，其中常见的主要任务有寻找适合推荐的物品、从一组物品中进行推荐、收集并改进用户数据、为推荐提供解释等功能。个性化推荐系统最基本的功能
是为用户提供符合他们口味的推荐。一个好的推荐系统应该具备下列几种能力，它们从不同的角度有效的应对了目前信息过载的这个问题
\begin_inset CommandInset citation
LatexCommand cite
key "39360168"

\end_inset

。
\end_layout

\begin_layout Enumerate
增加物品转换率。转化率指的是潜在客户完成一次商家期望的行动的比率。对于互联网电商而言，商品的售出可以看作是一次成功的转化。也就是一个好的推荐系统能够为电商向用户
出售更多的商品，带来更大的收益。原因是因为推荐的物品更加地符合用户的口味，更够强烈地激发起用户的购买欲望。对于非电商网站，比如豆瓣电台，虽然没有金额消费的发生，
但是转化可以表现为用户对于某个音乐的欣赏时间长、将其加入一收藏夹、鼠标点击“喜欢”等等。一个好的推荐系统它能够有效得增加物品的转化率。
\end_layout

\begin_layout Enumerate
提供多样化的推荐。比如对于Netflix电影推荐，推荐系统能够提不同类别的DVD推荐，而不是仅仅推荐热门的物品，多样化的推荐能够让用户发现那些冷门而他们喜爱的物
品。也只有推荐系统能够有这样挖掘冷门物品的能力，因为从利益角度来看，商家对这样的的物品进行大肆宣传是有极大的风险的。
\end_layout

\begin_layout Enumerate
增加用户的粘性。一个好的推荐系统它也能很大程度上给用户带来用户体验的增加。用户会感受到推荐很有吸引力，和自己的兴趣相关，那么他会更加的愿意使用这个系统，最终增加
了用户的满意度。同时，符合他口味的推荐让他也能感受到商家对自己的重视，增加用户的忠诚度。
\end_layout

\begin_layout Standard
上述的推荐系统的主要功能是从作为一个完整的可投入使用的系统角度来提出的。其中这些功能我们最常见的一个体现就是生成TopN推荐，如亚马逊的首页提供的TopN推荐，
见图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:亚马逊topN"

\end_inset

。而推荐评分预测问题是实现这些功能的一个基础。评分预测以某个用户未评分的物品为输入，产生对该用户给这个物品的评分的预测作为输出。产生的评分预测可以用于为推荐系统
作出推荐的一个重要参考。推荐系统的评分预测很容易用离线实验的方式来进行评估，通过对照预测值与真实值，用几种误差度量的方法来量化预测结果的准确性质。平凡预测问题主
要集中在学术界，本文也是主要致力于推荐系统产生预测的评分。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename 亚马逊推荐.png
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:亚马逊topN"

\end_inset

Amazon首页提供的TopN推荐
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
生成推荐的方式
\end_layout

\begin_layout Standard
根据上文所提到的，个性化推荐系统首先通过日志、数据等数据源分析用户的历史行为了解用户的兴趣，接着通过获取的兴趣来寻找符合用户口味的物品。主要有这么几种生成推荐的
方式
\begin_inset CommandInset citation
LatexCommand cite
key "2155197"

\end_inset

：
\end_layout

\begin_layout Enumerate
基于内容的推荐(content-based recommendation) 基于内容的推荐是利用已有的物品或者用户的信息，将其固有的特征抽离出来。物品信息抽离的
方式可以由人工得打上标签或者通过分类算法获得，用户的特征可以从算法其历史记录中获取。根据用户的特征为其推荐符合特征的物品。比如在网络书店中，一个用户他特征是“c
++程序员”，那么推荐系统很有可能为他推荐具有相同或者相似特征的书籍《c++ primer》。决策树、线性分类、朴素贝叶斯等方式常被应用于基于内容的推荐
\begin_inset CommandInset citation
LatexCommand cite
key "4117651"

\end_inset

。但是基于内容的推荐需要对数据进行预处理以获取特征，但是这个步骤在实际上非常困难的，比如给定一段音乐，想要计算机自动分析出它的音乐风格，需要很高的技术要求。其次
，基于内容的推荐产生的推荐往往局限在用户对应的特征中，导致推荐单一，很难发掘到用户潜在的兴趣。
\end_layout

\begin_layout Enumerate
协同过滤（collaborative算 filtering） 和基于内容的推荐不同，协同过滤推荐不需要对物品的特性有了解，它关注的是用户与物品之间的联系。通过对
历史记录的分析，了解用户与物品直接的联系，这些联系将会作为产生推荐的依据。比如一个人今天打算去看电影，他在选择电影前会问一问他的朋友最近看过什么电影，而他朋友的
过去选择将会影响他未来的选择，这就是协同过滤的核心思想。传统的两种协同过滤算法有基于用户的（user-based）和基于物品的（item-based）协同过滤。
基于用户的协同过滤基于这么一个假设：过去兴趣相似的用户在不远的未来将会保持相似的兴趣
\begin_inset CommandInset citation
LatexCommand cite
key "774803"

\end_inset

。协同过滤算法存在这样的问题：由于协同过滤依赖与用户的于研究评分预测问题。历史行为，那么推荐系统基于用户的（user-based）和基于物品的（item-bas
ed）协同过滤。基于用户的协同过滤将不知道为一个没有历史记录的新用户提供什么样的推荐。这个问题被称作冷启动问题(cold start)。冷启动问题的研究是推荐系
统领域的一个热门方向。
\end_layout

\begin_layout Enumerate
基于知识的推荐（Knowledge-based recommendation）基于知识的推荐是利用一些因果关系进行推理。比如一些商品用户往往只购买一次，然后在很
长一段时间内不会再对其进行再次购买。在用户购买这样的商品之后继续推荐类似的商品是不合适的。因此不应该把这一信息纳入到用户的兴趣中。在这种基于知识的推荐方式中，推
荐系统需要更多的信息，才能作出正确的推荐。基于知识的推荐很少单一使用，往往和其他方式组合起来，一起产生推荐。
\end_layout

\begin_layout Enumerate
混合推荐（Hybrid算 approaches）上述的几种方法有各自的优点和缺陷，混合推荐就是组合几种不同的推荐方式来互相弥补各种不足。如果一个推荐系统有额外的
社交信息可用，那么这个推荐系统可以通过混合推荐的方式来改进推荐结算果。混合推荐的一个典型的应用就是利用基于内容的推荐为协调过滤系统解决冷启动的问题。Kyung-
Yong Jun等人
\begin_inset CommandInset citation
LatexCommand cite
key "1793595"

\end_inset

将基于知识的推荐与基于内容的推荐组合起来，产生了更加精确的结果。对于评分预测问题，混合推荐也能达到更高的精确度。常用的
\end_layout

\begin_layout Standard
相对于其他的方式，协同推荐系统不需要人为地添加标签，大大减少了数据预处理时候产生的工作两。同时，协同过滤更擅长挖掘那些冷门的物品从而提供更多样化的推荐。最后协同
协同过滤算法在实际工程中表现出良好的推荐精确读。因此，协同过滤常常在个性化推荐系统中作为主要的方式被广泛使用。本文着重于研究协同过滤的方式。
\end_layout

\begin_layout Section
研究现状
\end_layout

\begin_layout Standard
推荐系统已经是机器学习，数据挖掘技术在工业界的一个代表性应用之一。伴随着市场的需求，越来越多的学者关注这一领域
\begin_inset CommandInset citation
LatexCommand cite
key "237066"

\end_inset

。著名的数据挖掘会议SIGKDD也开设了WEBKDD小组，用于研究电子商务技术以及推荐系统技术。在2001年，ACM的SIGIR为推荐系统开设了一个新的主题。2
007年，ACM Conference on Recommender Systems （简称RecSys）会议成立，直到2015年每年召开一次，它是是一个推荐系
统方向上的一个主要的会议。同时，越来越多的推荐系统或者相关内容的文章出现在著名的人工智能、数据挖掘、机器学习等领域的重要学术会议中，如AI Communicat
ions (2008); IEEE Intelligent Systems (2007); Inter-national Journal of
 Electronic Commerce (2006); International Journal of Com- puter Science
 and Applications (2006)等等。
\end_layout

\begin_layout Standard
在工业界，各大互联网公司的研发团队也着重致力于对推荐技术的研究。各大数据挖掘赛事也开设了许多推荐系统相关的项目。其中一个著名的比赛是
\begin_inset CommandInset href
LatexCommand href
name "Netflix Prize"
target "www.netflixprize.com"

\end_inset

，它由著名的在线电影公司Netlix举办。从2006年的第一届到2009年为止已经成功举办了三届。Netflix提供了他们的在线电影数据库，要求参赛者能在他们原
有的推荐系统Cinematch上至少提10%的高预测的准确率。冠军将会获得一百万美元的奖励。该赛事吸引了许多从事数据挖掘、推荐系统等领域的学者，并且在比赛中长生
了许多优秀的新算法，极大地推动了推荐系统领域的发展。
\end_layout

\begin_layout Standard
早期的推荐系统主要是基于内容的推荐，需要分析资源的内容信息
\begin_inset CommandInset citation
LatexCommand cite
key "303284,245168"

\end_inset

。由于分析资源内容信息较为困难以及难以提供的推荐物品的范围小等问题，研究者提出稀疏度了协调过滤的推荐方法
\begin_inset CommandInset citation
LatexCommand cite
key "777495,777206,774803,340335"

\end_inset

。GroupLens小组使用的是基于用户的协同过滤方法
\begin_inset CommandInset citation
LatexCommand cite
key "340335,774803"

\end_inset

，这种方法主要根据用户之间的相似度来提供推荐。Karypis等人在2001年提出基于物品的协同过滤方法
\begin_inset CommandInset citation
LatexCommand cite
key "804402,124971"

\end_inset

，并且在GroupLens数据集上获得了想对于基于用户的方法更加精确的结果
\begin_inset CommandInset citation
LatexCommand cite
key "499786"

\end_inset

。与基于用户的协同过滤不同，基于物品的协同过滤是根据物品之间的相似的来提供推荐的。文章
\begin_inset CommandInset citation
LatexCommand cite
key "107804"

\end_inset

提出基于图的算法来计算用户的相似度。协同过滤推荐面临的一个主要问题是数据的稀疏性，用户评分过的物品在总的物品集合中只占据了很小的一部分，对于一些噪声比较敏感，这
将会导致推荐质量的下降。对于这种问题，Sarwar等人
\begin_inset CommandInset citation
LatexCommand cite
key "205701"

\end_inset

采用奇异值分解（Singular Value Decomposition对 ）的方法来减少物品矩阵的维度，提高推荐的质量。Simon Funk等人
\begin_inset CommandInset citation
LatexCommand cite
key "NetflixUpdateTryThisatHome"

\end_inset

在SVD基础上作出了优化，在Netflix Prize上取得了优异的结果，后来被称作隐语模型（Latent Factor Model）。
\end_layout

\begin_layout Standard
由于用户与物品的数量庞大，进行一次离线计算将花费大量的时间，推荐结果的时效性难以保障。针对这一问题，不同学者也提出了一些优化的方法。上述奇异值分解是一个有效的方
法。文章
\begin_inset CommandInset citation
LatexCommand cite
key "1284393,485233,295125"

\end_inset

采用聚类的方法，把用户分为几个簇，在在簇内进行寻找邻居，而不是在全局范围内搜索邻居，减少了计算量。文章
\begin_inset CommandInset citation
LatexCommand cite
key "56775"

\end_inset

提出了一种RecTree的算法来减少搜索空间。
\end_layout

\begin_layout Section
本文工作
\end_layout

\begin_layout Subsection
本文研究内容的与成果
\end_layout

\begin_layout Standard
针对目前推荐系统的一些问题，本文主要研究推荐系统的架构以及算法的设计。本文使用的是MovieLens的数据集，采用协同过滤的方法对用户提供评分预测。本文主要工作
内容如下：
\end_layout

\begin_layout Standard
1.推荐引擎TinyRec设计与实现。目前各大互联网公司使用的都是自己开发的推荐系统，开源的推荐框架并不是很多，针对这种情况，本文给出了一个推荐引擎TinyRec
的实现。一个完整的推荐系统除了推荐引擎之外，包括前台web展示页面的支持以及数据收集清洗模块以及后台复杂的业务流程。本文目前实现的是提供评分预测的一个推荐引擎。
TinyRec是一个轻量级的推荐引擎，可以作为一个推荐框架使用。它可以从给定的数据集中读取数据并将其结构化。它提供不同的数据存储方式的支持，可以支持基于内存的数
据库如Redis，也可以支持关系型数据库。它可以通过配置文件灵活得选择各种算法。它还提供了根据推荐结果计算推荐精确度的功能。TinyRec为本文各种算法研究以及
推荐结果分析提供了支持。
\backslash
hline 
\backslash
hline 
\end_layout

\begin_layout Standard
2.协同过滤算法的设计与实现。本文分别给出了主流的基于用户的协同过滤算法和基于物品的协调过滤算法的实现。对于不同的相似度算法，如余弦相似度、pearson相关系数
、spearman相关系数，本文研究了一些实现的细节。针对协同过滤算法用户对物品评分的稀疏性问题，本文还实现了一个简单的稀疏向量的运算库。针对协同过滤算法复杂度
高这一问题，本文给出了算法并行化的实现，使之能够更加充分得利用计算资源，减少计算时间。
\end_layout

\begin_layout Standard
3.各种协同过滤算法的比较与分析。目前，对于一个协同过滤的推荐引擎，存在许多算法的选择。比如对于基于用户的协调同推荐算法的相似度度量方式，就有余弦相似度、pear
son相关系数、spearman相关系数这几种，对于每种相似度度量方式，就有不同的修正方式。比如使用pearson相关系数的相似度度量算法可以选择默认评分填补（
Default Voting）、重要性权重（Significance Weighting）等修正方式。同时相同算法下也有不同可选的参数，比如采用KNN来进行评分
预测时候邻域大小K值的选择也会影响预测的结果。本文通过控制变量的方式，研究了不同的算法、相同算法下不同参数的选择对的评分预测精度影响，并根据结果给出了分析。最终
分析了不同协同过滤算法的特性以及在实际应用中的选择subsection{推荐系统介绍} 考虑。
\end_layout

\begin_layout Subsection
本文结构
\end_layout

\begin_layout Standard
本文一共分为五章，文章结构以及各章内容如下：
\end_layout

\begin_layout Section
术语和记号
\end_layout

\begin_layout Standard
在协同过滤的算法的评分预测问题中，使用的数据集是由用户的评分记录所构成的，每一条记录最主要的内容可以用一个三维的向量表示：
\begin_inset Formula $\left(u,i,r\right)$
\end_inset

。它的意思是用户
\begin_inset Formula $u$
\end_inset

为物品
\begin_inset Formula $i$
\end_inset

给出了
\begin_inset Formula $r$
\end_inset

的打分。用户（user）指的是为物品打分的个体，物品（item）在其他文章中也称作商品，对于某种特点应用的推荐系统中，物品可以是电影、音乐、文章等，本文中都称为
物品。评分可以体现用户对物品的喜爱程度，它可以从用户主动提供的显式评分，如打分，喜欢等方式获得，也可以根据用户在页面上的行为获取隐式评分，比如页面停留时间、物品
的转换、页面的点击等等。本文讨论的评分是由MovieLens数据集直接给出的评分，是用户的显式地为电影作出的打分。其有效评分范围1～5分，分值为整数。本文的讨论
的评分都是按照这种机制。是在本文中，集合使用大写英文字母表示。
\end_layout

\begin_layout Standard
本文中，数据集被分割为两个部分，训练数据集（training dataset）和测试数据集（testing dataset）。用于挖掘关联关系的训练数据集记为
\begin_inset Formula $Tr$
\end_inset

，用于检验算法的测试数据集记为
\begin_inset Formula $Ts$
\end_inset

。具体的记号见表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:本文术语表格"

\end_inset

。更多特点算法相关的记号会在文章中指出。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
记号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
定义
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
可用的评分集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $U$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有用户的集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有物品的集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $u$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
第
\begin_inset Formula $u$
\end_inset

个用户
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $i$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
第
\begin_inset Formula $i$
\end_inset

个物品
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $r_{u,i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\begin_inset Formula $u$
\end_inset

对物品
\begin_inset Formula $i$
\end_inset

的评分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
对于
\begin_inset Formula $r_{u,i}$
\end_inset

的预测值
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{r_{u}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\begin_inset Formula $u$
\end_inset

的平均打分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\overline{r_{i}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
物品
\begin_inset Formula $i$
\end_inset

的平均打分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $U_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
所有评价过物品
\begin_inset Formula $i$
\end_inset

的用户集合
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{u}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\begin_inset Formula $u$
\end_inset

评价过的所有物品集合
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:本文术语表格"

\end_inset

本文中使用的各种记号与术语
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
协同过滤推荐关键技术介绍
\end_layout

\begin_layout Section
基于邻域的评分预测
\end_layout

\begin_layout Standard
协同过滤问题常常可以表示为一subsection{推荐系统介绍} 个用户对物品的矩阵，在这个矩阵中每个元素代表一个用户对特点物品的评分。由于协同过滤问题的特点，
这个矩阵非常稀疏
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

，因为一个用户通常只评价了占物品集合中很小一部分的物品。对于一个基于邻域的评分预测就是要根据用户的领域来找出这个矩阵的某个空值最可能的值。换句话说，一个用户给物
品的评分更加依赖于和他有相似兴趣的人或者其他可信任的数据源。为了说明这一核心思想，见表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:四个用户为电影的评分表格"

\end_inset

，表中有四个用户对四部电影的不同评分，评分取值范围为1～5分，空值表示该用户未能给该电影评分，而问号是我们即将要对其给出预测。首先张三和赵六的兴趣比较相似，因为
他们喜欢相同的电影，给星球大战和超时空接触打了高分，并且不怎么喜欢篮球梦。而对比赵六和剩下两个人的兴趣，发现他们的兴趣不是那么一致，因此张三给泰坦尼克的分数将作
为我们主要的参考来预测赵六的评分。而李四和王五的评分对预测结果的影响就非常小了。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星球大战
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
篮球梦
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
超时空接触
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
泰坦尼克
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
张三
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
李四
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
王五
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
赵六
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
？
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:四个用户为电影的评分表格"

\end_inset

一个电影评分预测的例子，四个用户为电影的评分表格
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
基于用户的协同过滤
\end_layout

\begin_layout Standard
基于用户的协同过滤是早期协调过滤推荐系统中最常用的算法。在1994年GroupLens小组采用基于用户的协同过滤算法来为用户提供新闻推荐
\begin_inset CommandInset citation
LatexCommand cite
key "340335"

\end_inset

。直到基于物品的协同过滤出现以前，它一直是推荐领域中最热门的算法。比如在一个个性化推荐系统中，用户A需要得到推荐时，推荐系统会先找到和它有相似兴趣的用户，把那些
用户喜欢的而用户A没有接触过的物品推荐给A。类似的，在评分预测问题中，基于用户的协同过滤通过寻找与目标用户最相似的一群用户，根据他们的打分情况来提供评分预测。基
于用户的协同过滤假设一群用户的兴趣在过去的历史记录中相似，那么在未来的一段时间内，他们的兴趣仍然相似。所以在用户A需要得到对于某个物品的推荐或者需要进行评分预测
时候，我们有足够的理由相信，和用户A有相同兴趣的那些用户对这个物品的评价与用户A将来对它的评价很相似。
\end_layout

\begin_layout Standard
通过以上表述，我们可以得出基于用户的协同过滤算法需要下边这两个过程；
\end_layout

\begin_layout Enumerate
寻找和目标用户相似的用户集合。
\end_layout

\begin_layout Enumerate
根据这个用户的集合里其他用户的评价，产生这个用户的评分预测。
\end_layout

\begin_layout Standard
为了寻找和目标用户相似的用户集合，我们首先得知道两个用户之间相似度的计算方法。常见的相似度计算方法在章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

中描述。假设我们需要为用户
\begin_inset Formula $u$
\end_inset

提供物品
\begin_inset Formula $i$
\end_inset

的评分预测
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

。首先我们在用户集合
\begin_inset Formula $U$
\end_inset

中找出评价过物品
\begin_inset Formula $i$
\end_inset

的用户集合
\begin_inset Formula $U{}_{i}$
\end_inset

，其中
\begin_inset Formula $u\notin U{}_{i}$
\end_inset

。接着两两计算用户
\begin_inset Formula $u$
\end_inset

与
\begin_inset Formula $U{}_{i}$
\end_inset

中的每个用户的相似度，挑选与
\begin_inset Formula $u$
\end_inset

相似的用户，我们得到了与用户
\begin_inset Formula $u$
\end_inset

最相似的用户集合，用
\begin_inset Formula $\mathcal{N}_{i}(u)$
\end_inset

表示。选取该最相似集合的方法在章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:用K邻近算法预测"

\end_inset

中描述。我们可以简单地使用来作为
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\frac{1}{\left|\mathcal{N}_{i}(u)\right|}\underset{v\in\mathcal{N}_{i}(u)}{\sum}r_{u,i}\label{eq:邻域内用户对i评分的平均值}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
上述公式假设我们需要为用户
\begin_inset Formula $u$
\end_inset

提供物品
\begin_inset Formula $i$
\end_inset

的评分预测
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

。
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:邻域内用户对i评分的平均值"

\end_inset

存在一个问题，它没有考虑到这样一个事实，在选取的邻域内的用户与目标用户
\begin_inset Formula $u$
\end_inset

有着不同的相似度，不同同相似度的用户在参与给出评分时的影响不同：相似度高的用户应当对结果有更大的影响。一个普遍的解决方法是，令两个用户之间的相似度作为权重，记为
\begin_inset Formula $w_{u,i}$
\end_inset

。此时公式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:邻域内用户对i评分的平均值"

\end_inset

可写作：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\frac{\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}r_{v,i}}{\underset{v\in\mathcal{N}_{i}(u)}{\sum}\left|w_{u,v}\right|}\label{eq:添加权重的评分}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
公式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:添加权重的评分"

\end_inset

更加符合我们的期望，其中注意到分母中
\begin_inset Formula $w_{u,i}$
\end_inset

使用了绝对值，是因为相似度可以正相关，也可以负相关，更多的讨论见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

。
\end_layout

\begin_layout Subsection
基于物品的协同过滤
\end_layout

\begin_layout Standard
相对于基于用户的协同过滤算法，基于物品的协同过滤算法注重于物品之间的相似度。它是Karypis等人在2001年提出基于的
\begin_inset CommandInset citation
LatexCommand cite
key "804402,124971"

\end_inset

，亚马逊的科学家也提出了相似的理论
\begin_inset CommandInset citation
LatexCommand cite
key "861437"

\end_inset

。基于物品相似度的一个特点是不同于用户之间的相似度，物品之间的相似度比较稳定，基本只要计算一次就可以长时间使用。用户之间的相似度可能随着用户评价更多的物品或者用
户的兴趣变化的而逐渐变化，因此过一段时间需要重新计算。基于物品的协同过滤基于这样的一个假设，有两个相似的物品A和B，对于一个特定的用户来说，该用户对物品A的评价
应该和对于物品B的评价接近。类似与基于用户的协同过滤算法，基于物品的协同过滤算法可以分为下边几个步骤：
\end_layout

\begin_layout Enumerate
在用户参与过评分的物品中寻找与目标商品相似的物品集合。
\end_layout

\begin_layout Enumerate
根据该用户给相似的物品集合中物品的评分给出目标商品的预测评分。
\end_layout

\begin_layout Standard
我们可以在寻找相似物品集合之前先计算好物品之间的相似度。我们也可以用
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

中描述的相似读计算方法来计算。这一过程可以形式化地描述为，为了给用户
\begin_inset Formula $u$
\end_inset

提供物品
\begin_inset Formula $i$
\end_inset

的评分预测
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

，我们必须找到和用户
\begin_inset Formula $u$
\end_inset

评分过的物品中与物品
\begin_inset Formula $i$
\end_inset

最相似的物品集合
\begin_inset Formula $\mathcal{N}_{u}(i)$
\end_inset

。我们把两个物品之间的相似度作为权重
\begin_inset Formula $w$
\end_inset

，那么可以这样来描述评分预测的公式：
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\frac{\underset{j\in\mathcal{N}_{u}(i)}{\sum}w_{i,j}r_{u,j}}{\underset{j\in\mathcal{N}_{u}(j)}{\sum}\left|w_{i,j}\right|}\label{eq:基于物品的评分}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
相似度度量方法
\begin_inset CommandInset label
LatexCommand label
name "sub:相似度度量方法"

\end_inset


\end_layout

\begin_layout Subsubsection
余弦相似度
\end_layout

\begin_layout Standard
一种最基本的计算两个个体的相似读的方法是余弦相似度
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。余弦相似度计算两个向量之间的夹角，其取值范围为
\begin_inset Formula $(-1,1)$
\end_inset

。夹角越小，表示两个向量之间正相关度越高，越接近1，反之则接近-1，表现出负相关性。设两个向量为
\begin_inset Formula $\mathbf{x}_{a}$
\end_inset

、
\begin_inset Formula $\mathbf{x}_{b}$
\end_inset

，则他们之间的相似度可以表示为：
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{a},\mathbf{x}_{b})=\frac{\mathbf{x}_{a}^{\top}\mathbf{x}_{b}}{\left\Vert \mathbf{x}_{a}\right\Vert \left\Vert \mathbf{x}_{b}\right\Vert }\label{eq:cos相似度}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
在基于用户的协同推荐算法中，我们可以用式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度"

\end_inset

来表示两个用户
\begin_inset Formula $u$
\end_inset

和
\begin_inset Formula $v$
\end_inset

之间的相似度。我们把用户
\begin_inset Formula $u$
\end_inset

看作是一个向量
\begin_inset Formula $\mathbf{x}_{u}\in\mathbb{R}^{\left|I\right|}$
\end_inset

,其中如果用户
\begin_inset Formula $u$
\end_inset

给物品
\begin_inset Formula $i$
\end_inset

有过评分，那么
\begin_inset Formula $\mathbf{x}_{ui}=r_{u,i}$
\end_inset

，其他则为0。那么式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度"

\end_inset

可写成：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{u},\mathbf{x}_{v})=\frac{\underset{i\in I_{u}\cap I_{v}}{\sum}r_{u,i}r_{v,i}}{\sqrt{\underset{i\in I_{u}}{\sum r_{u,i}^{2}}\underset{j\in I_{v}}{\sum r_{v,j}^{2}}}}\label{eq:cos相似度基于用户}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
在基于物品的协同过滤算法中，类似的我们把物品
\begin_inset Formula $i$
\end_inset

看作是一个向量
\begin_inset Formula $\mathbf{\bar{r_{v}})x}_{i}\in\mathbb{R}^{\left|U\right|}$
\end_inset

，如果用户
\begin_inset Formula $u$
\end_inset

给物品
\begin_inset Formula $i$
\end_inset

有过评分，那么
\begin_inset Formula $\mathbf{x}_{iu}=r_{u,i}$
\end_inset

，其他则为0。那么两个物品
\begin_inset Formula $i$
\end_inset

，
\begin_inset Formula $j$
\end_inset

的相似读可写成：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{i},\mathbf{x}_{j})=\frac{\underset{u\in U_{i}\cap U_{j}}{\sum}r_{u,i}r_{u,j}}{\sqrt{\underset{u\in U_{i}}{\sum r_{u,i}^{2}}\underset{v\in U_{j}}{\sum r_{v,j}^{2}}}}\label{eq:cos相似度基于物品}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
余弦相似度可以进一步根据用户个人的打分习惯来调整，见章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:用K邻近算法预测"

\end_inset


\end_layout

\begin_layout Subsubsection
pearson相关系数
\end_layout

\begin_layout Standard
pearson相关系数可以用于衡量一组数据的线性相关程度。与余弦相似度相似，相关系数的绝对值越大，相关程度越高。给定两组离散的数据x，y我们可以计算他们的pea
rson相关系数，其中
\begin_inset Formula $\sigma$
\end_inset

表示为数据的标准差：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Pearson(x,y)=\frac{\sum(x,y)}{\sigma_{x}\sigma_{y}}\label{eq:pearson base}
\end{equation}

\end_inset

在基于用户的协同推荐算法中，用户u和用户v之间的pearson相关系数为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{uv}=Pearson(u,v)=\frac{\underset{i\in I_{u}\cap I_{v}}{\sum}(r_{u,i}-\bar{r_{u}})\cdotp(r_{v,i}-\bar{r_{v}})}{\sqrt{\underset{i\in I_{u}}{\sum}(r_{u,i}-\bar{r_{u}})^{2}\underset{i\in I_{v}}{\sum}(r_{v,i}-\bar{r_{v}})^{2}}}\label{eq:pearson user base-}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
在基于物品的协同推荐算法中，物品
\begin_inset Formula $i$
\end_inset

和物品
\begin_inset Formula $j$
\end_inset

之间的pearson相关系数为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{ij}=Pearson(i,j)=\frac{\underset{u\in U_{i}\cap U_{j}}{\sum}(r_{u,i}-\bar{r_{i}})\cdotp(r_{u,j}-\bar{r_{j}})}{\sqrt{\underset{u\in U_{i}}{\sum}(r_{u,i}-\bar{r_{i}})^{2}\underset{u\in U_{j}}{\sum}(r_{u,i}-\bar{r_{j}})^{2}}}\label{eq:pearson item base}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
pearson相关系数是依赖与数据符合正态分布的假设，不过大部分实际的数据都能符合这个假设。如果假设不成立的话，可以使用
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:spearman秩相关系数"

\end_inset

描述的spearman相关系数。
\end_layout

\begin_layout Subsubsection
spearman秩相关系数
\begin_inset CommandInset label
LatexCommand label
name "sub:spearman秩相关系数"

\end_inset


\end_layout

\begin_layout Standard
和pearson相关系数不同，spearman秩相关系数不对原始变量作特殊的要求，因此对于不服从正态分布、分布未知的变量可以使用spearman秩相关系数。sp
earman秩相关系数计算时先把变量X，Y成对的值从哦按照从小到大的顺序排列，将原始的数值映射成秩，再按照pearson相关系数来计算相关度。
\end_layout

\begin_layout Standard
在基于用户的协同过滤算法中，设用户
\begin_inset Formula $u$
\end_inset

，
\begin_inset Formula $v$
\end_inset

的评分被映射成
\begin_inset Formula $rank$
\end_inset


\begin_inset Formula $_{u}$
\end_inset

，
\begin_inset Formula $rank_{v}$
\end_inset

，秩的平均值为
\begin_inset Formula $\overline{rank_{u}}$
\end_inset

，
\begin_inset Formula $\overline{rank_{v}}$
\end_inset

，秩的标准差记为
\begin_inset Formula $\sigma_{u}$
\end_inset

，
\begin_inset Formula $\sigma_{v}$
\end_inset

,
\begin_inset Formula $m$
\end_inset

为共同评分的个数。则spearman秩相关系数为：
\begin_inset Formula 
\begin{equation}
w_{uv}=Spearman(u,v)=\frac{\stackrel[i=1]{m}{\sum}(rank_{u,i}-\overline{rank_{u}})\cdotp(rank_{v,i}-\overline{rank_{v}})}{\sigma_{u}\sigma_{v}}\label{eq:spearman user base}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
相似的，基于物品的协同过滤算法中，spearman秩相关系数为：
\begin_inset Formula 
\begin{equation}
w_{ij}=Spearman(i,j)=\frac{\stackrel[u=1]{m}{\sum}(rank_{i,u}-\overline{rank_{i}})\cdotp(rank_{j,u}-\overline{rank_{j}})}{\sigma_{i}\sigma_{j}}\label{eq:spearman user base-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
重要性权重（Significance Weighting）
\begin_inset CommandInset label
LatexCommand label
name "sub:重要性权重（Significance-Weighting）"

\end_inset


\end_layout

\begin_layout Standard
如果给定的两个用户之间可用的数据量很小，那么上述相关性度量方法将不能很客观的表现它们直接的相关度量，比如如下情况：在计算用户A和用户B的相似度时，用户A，B共同
评分过的物品只有X，Y，无论A和B为X，Y打了多少分，pearson相关系数和spearman秩相关系数总会给出绝对值为1的很高的相关性。而这与我们的期望所违背
。同时，从直觉上我们还认为，如果两个用户共同评价的物品越多，那么计算出的相似度就越具有参考价值。Herlocker 等人针对这个问题提出了重要性权重（Signi
ficance Weighting）这一解决方法
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。主要思想就是，在计算相似度的时候，给那些共同参与物品特别少的用户之间的相似度作出惩罚：
\begin_inset Formula 
\begin{equation}
w_{uv}^{\prime}=\frac{min\{\left|I_{u}\cap I_{v}\right|,\gamma\}}{\gamma}\times w_{uv}\label{eq:significance weighting user}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
类似的针对物品直接的相似度我们也可以使用如下的方法：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{ij}^{\prime}=\frac{min\{\left|U_{i}\cap U_{j}\right|,\gamma\}}{\gamma}\times w_{uv}\label{eq:significance weighting item}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
其中
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\gamma$
\end_inset

是一个参数，它表示一个阈值，如果相同物品，或者相同用户的数量小于这个阈值，该相似度就会收到惩罚，文章
\begin_inset CommandInset citation
LatexCommand cite
key "706157,JonathanLHerlocker1999An"

\end_inset

表明，当
\begin_inset Formula $\gamma>25$
\end_inset

时候，评分预测的精确度得到很大的提升，
\begin_inset Formula $\gamma=50$
\end_inset

时将会达到最好的结果。
\end_layout

\begin_layout Subsubsection
方差权重
\end_layout

\begin_layout Subsection
评分标准化
\end_layout

\begin_layout Standard
在实际情况中，每个用户都有自己的打分习惯。有些人比较喜欢给电影打高分，个自己不喜欢的电影三分，有些人的打分则比较严厉，非常谨慎地打高分。我们在为用户作出平凡预测
的时候，应当考虑到这些情况，要根据每个人打分习惯的不同情况来提供预测。评分标准化的过程可以放在数据预处理阶段做，也可以调整计算公式。
\end_layout

\begin_layout Subsubsection
均值中心化
\end_layout

\begin_layout Standard
均值中心化
\begin_inset CommandInset citation
LatexCommand cite
key "breese1998empirical"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "340335"

\end_inset

的思想是通过评分与标准值来比较，从而决定评分的情况。在使用余弦相似度计算相似度时候，可以调整式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度基于用户"

\end_inset

为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cos(\mathbf{x}_{u},\mathbf{x}_{v})=\frac{\underset{i\in I_{u}\cap I_{v}}{\sum}(r_{u,i}-\overline{r_{u}})(r_{v,i}-\overline{r_{u}})}{\sqrt{\underset{i\in I_{u}}{\sum(r_{u,i}-\overline{r_{u}}}\underset{j\in I_{v}}{)^{2}\sum(r_{v,j}}-\overline{r_{v}}})^{2}}\label{eq:cos相似度基于用户-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:cos相似度基于物品"

\end_inset

同理，不再赘述。而pearson相关系数与spearman秩相关系数均考虑了均值的情况，所以不需要调整。在生成评分时，基于物品的协同过滤算法可以直接使用
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:基于物品的评分"

\end_inset

，因为选取的用户对其他物品的评分已经包含了用户的个人习惯。而对于基于用户的协同过滤算法则需要调整式
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:添加权重的评分"

\end_inset

为：
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\overline{r_{u}}+\frac{\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}(r_{v,i}-\overline{r_{v}})}{\underset{v\in\mathcal{N}_{i}(u)}{\sum}\left|w_{u,v}\right|}\label{eq:基于用户的KNN-中心化}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Z分布
\end_layout

\begin_layout Standard
相对于均值中心化，Z分布考虑了用户评分的方差
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。比如，用户A打分时候，经常给分范围是1分到5分，而用户B大部分的评分都是三分。在这种情况下，用户B给一个物品打了五分的事实将会比A给出五分的事实更少见，因此表
现出B对这个这个物品更高的喜爱度。同样的，在基于用户和基于物品中使用Z分布来标准化时处理方法不同。基于用户的协同过滤中评分预测公式为：
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\overline{r_{u}}+\sigma_{u}\frac{\underset{v\in\mathcal{N}_{i}(u)}{\sum}w_{u,v}(r_{v,i}-\overline{r_{v}})/\sigma_{v}}{\underset{v\in\mathcal{N}_{i}(u)}{\sum}\left|w_{u,v}\right|}\label{eq:基于用户的zcore预测}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
其中，
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sigma_{u}$
\end_inset

和
\begin_inset Formula $\sigma_{v}$
\end_inset

分别表示用户u与用户v的评分的方差。同样的，对于基于物品的评分预测公式为:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\begin{equation}
\hat{r}_{u,i}=\overline{r_{i}}+\sigma_{i}\frac{\underset{j\in\mathcal{N}_{u}(i)}{\sum}w_{i,j}(r_{u,i}-\overline{r_{j}})/\sigma_{j}}{\underset{j\in\mathcal{N}_{u}(i)}{\sum}\left|w_{i,j}\right|}\label{eq:基于物品的zcore预测}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
邻域选取
\begin_inset CommandInset label
LatexCommand label
name "sub:用K邻近算法预测"

\end_inset


\end_layout

\begin_layout Standard
在提供评分预测时，邻域的选取将会很大地影响到预测的结果。主要的邻域选取方式有如下几种
\end_layout

\begin_layout Itemize
Top-N选取。对于每个用户和物品，只要存储N个最相似的邻居，并且使用他们来进行预测。其中，N的选择非常重要，过低N值将会导致评分预测的准确率不知，而过高的N也
会带来准确率下降和是用大量计算资源
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An"

\end_inset

。
\end_layout

\begin_layout Itemize
阈值选取。和Top-N过滤不同，阈值选取的方法选取所有能符合要求，即大于某个阈值的所有用户或者物品来作为邻居。这个方法更加灵活，只保留了那些对提供预测有最重要参
考意义的邻居，但是这个阈值的选取比较困难。
\end_layout

\begin_layout Itemize
负值过滤。使用由上文
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:相似度度量方法"

\end_inset

提出的方法来计算相似度的区间范围是[
\begin_inset Formula $-1,1]$
\end_inset

。理论上来说，接近
\begin_inset Formula $-1$
\end_inset

的相似度表明两组数据间具有强烈的负相关性。但是在实际中，两个用户的的评分负相关只是表明这两个用户没有相似的兴趣，但是却没有表示出他们的兴趣究竟差了多少。直观上来
看，负相关也没有正相关对两个个体相似度的描述更有说服力。有实验证明
\begin_inset CommandInset citation
LatexCommand cite
key "JonathanLHerlocker1999An,good1999combining"

\end_inset

使用负值的相似度并不能带来更加准确的结果。本文中的实现没有使用负值的相似度。
\end_layout

\begin_layout Section
预测精确率度量
\end_layout

\begin_layout Subsection
度量方法
\end_layout

\begin_layout Standard
平凡预测问题很容易离线地进行实验。常见的度量方法有均方根误差（RMSE）和平均绝对误差（MAE）。设
\begin_inset Formula $\hat{r}_{u,i}$
\end_inset

是推荐算法给用户
\begin_inset Formula $u$
\end_inset

对物品
\begin_inset Formula $i$
\end_inset

的评分预测，它预测的是根据测试数据集
\begin_inset Formula $Tr$
\end_inset

中的历史数据而给出的。设
\begin_inset Formula $r_{u,i}$
\end_inset

是在测试数据集
\begin_inset Formula $Ts$
\end_inset

中实际存在的评分那么RMSE可以通过下式计算：
\begin_inset Formula 
\begin{equation}
RMSE=\frac{\sqrt{\underset{u,i\in Ts}{\sum}(\hat{r}_{u,i}-r_{u,i})^{2}}}{\left|Ts\right|}\label{eq:RMSE}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
而平均绝对误差使用绝对值来计算：
\begin_inset Formula 
\begin{equation}
MAE=\frac{\underset{u,i\in Ts}{\sum}\left|\hat{r}_{u,i}-r_{u,i}\right|}{\left|Ts\right|}\label{eq:MAE}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Netflix认为RMSE对系统的评测更加严格，因为RMSE的平方项加大了对预测与实际的偏差的惩罚。在Netflix Prize中使用的也是RMSE来评判系统评
分预测结果的。而研究表明如果合法的评分是整数，那么对预测结果的取整后再进行精确度度量将会降低MAE的误差
\begin_inset CommandInset citation
LatexCommand cite
key "takacs2007major"

\end_inset

。
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:交叉验证与数据分割"

\end_inset

交叉验证与数据分割
\end_layout

\begin_layout Standard
交叉验证是一种统计学的方法，它将数据样本集合切割成多份，选取一部分用来分析，而剩余部分用来对此分析的确认和验证
\begin_inset CommandInset citation
LatexCommand cite
key "kohavi1995study"

\end_inset

。k-ford方法是一种常见的交叉验证方法。它平均地把原始数据集合分割成K份，挑选其中的一份作为测试集，剩余的部分作为训练集合。重复这样的过程K次，使得K份中的
每一份都能被选中作为测试集合。在机器学习领域中，k-ford方法能够有效地避免过度拟合和欠拟合的情况发生。在评分预测问题中，可以把原有数据集分成10份，分别作出
10次的评分预测以及验证精确度的过程。再取10次精确度结果的平均作为最终对算法精度的估计。其中K值选择为10是一个经验上的考虑。
\end_layout

\begin_layout Standard
在分割数据时，应当考虑如下的问题：分割时候应该对每个用户的所有评分做一次分割，这样能够最大限度地保证每个用户有足够的信息来为评分预测提供依据。比如两个用户A，B
的评分如表
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:评分分割例子"

\end_inset

，我们需要将十个记录分割成两份，我们更希望分割的结果是
\begin_inset Formula $(1,3,5,6,8)$
\end_inset

和
\begin_inset Formula $(2,4,7,9,10)$
\end_inset

而不是
\begin_inset Formula $(1,2,3,4,5)$
\end_inset

和
\begin_inset Formula $(6,7,8,9,10)$
\end_inset

。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
记录序号
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
用户
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
电影名称
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
评分
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星球大战
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星际迷航
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
泰坦尼克
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
低俗小说
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
阿甘正传
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
泰坦尼克
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星球大战
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
低俗小说
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
星际迷航
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
阿甘正传
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:评分分割例子"

\end_inset

两个用户的评分例子
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
一个基于协同过的评分预测引擎TinyRec的实现 
\end_layout

\begin_layout Section
TinyRec总体介绍
\end_layout

\begin_layout Standard
为了给本文的算法实现、运行与检测提支持，本文实现了一个轻量集推荐引擎TinyRec。TinyRec的主要功能就是对已经经过预处理的数据进行计算分析，为用户提供评
分预测。TinyRec没有提供用户界面，而是和其他系统进行交互，提供推荐。TinyRec可以灵活地与各种算法结合，可以轻松地替换所需的算法，只需要用户实现所需算
法再修改下配置文件的参数。TinyRec还支持各种不同的数据存储方式，如关系型数据库，部分NoSQL数据库，以及文件等。不仅如此，TinyRec还提供了一些基本
的推荐系统所具备的功能，比如推荐精确度评估、数据分割、交叉验证等功能。TinyRec全部使用python语言
\begin_inset Foot
status open

\begin_layout Plain Layout
使用的是python2，版本为2.7.6。
\end_layout

\end_inset

编写，为跨平台提供了很好的支持。另外，目前适合python的科学计算库有Numpy和Scipy，但是其没有很好地提供稀疏向量的支持，因此，TinyRec内部还实
现了一个稀疏向量的运算库。
\end_layout

\begin_layout Section
系统功能模块划分 
\end_layout

\begin_layout Standard
TinyRec按照功能的需求的要求可以分成如下模块：数据预处理模块，参数配置模块，推荐算法模块，数据存储模块以及精确度测量模块。如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:系统总功能模块图"

\end_inset

所示。
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename 系统功能模块图.eps
	width 100col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:系统总功能模块图"

\end_inset

系统总功能模块图
\end_layout

\end_inset


\end_layout

\end_inset

数据预处理模块负责执行推荐算法之前的数据处理。可用的数据集在使用之前必须要分割成训练集和测试集合，数据分割模块提供了对一个原始数据集分割的功能，将按照要求分割后
输出训练集合和测试集，一遍于后边算法精确度的测量。数据导入模块是将以文件形式的数据记录集合结构化，数据执行导入之后将会被按照数据存储模块提供的功能存放，可以是数
据库存储方式，直接内存存储方式，或者文件的存储方式。方便后边执行推荐算法以及精确度测量时候使用。
\end_layout

\begin_layout Standard
推荐算法模块是TinyRec最核心的功能。它可以针对结构化的数据记录进行关联挖掘。在基于用户和基于物品的推荐算法中，它负责的功能就是用户之间、物品之间的相似度计
算。评分预测模块就是根据获取到的这些关联，来进行预测工作。评分预测模块就是根据要求来给出特定用户对特定物品的评分。
\end_layout

\begin_layout Standard
精确度测量模块负责把测试数据集应用于推荐算法模块所生成的预测模型中，通过预测模型给出的预测结果和训练集数据比较来计算精确度。精确度计算模块为提供具体的精确度计算
方法，本文实现了RMSE和MAE这两种方法。交叉验证模块提供交叉验证的功能，它与精确度计算模块共同提供衡量算法精确度的功能。
\end_layout

\begin_layout Section
系统体系结构设计
\end_layout

\begin_layout Standard
TinyRec的系统架构如图
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:TinyRec的系统架构图"

\end_inset

所示。TinyRec每个模块被打包成python包，以方便独立使用。TinyeRec在与数据存储通信是通过DAO层，各个模块只要调用其提供的API即可传输数据而
不用考虑具体实现。最初数据集由数据导入模块通过DAO层导入数据库中或内存中，目前TinyRec使用Redis数据库。其中各个模块直接并不直接联系，计算得到的必须
提供给其他模块的中间数据一般都放在数据库中，其他模块再自己获取。比如数据导入模块将数据结构化存入Redis中，然后相似度计算模块再从中获取每一条记录。图中每个模
块的参数配置都从参数配置模块中获取。推荐算法可以自由地在基于用户和基于物品算法中选取，这些也可以通过配置模块来修改。评分预测模块输出的预测结果可以用于计算算法的
精确度量。
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename 系统架构图.eps
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:TinyRec的系统架构图"

\end_inset

TinyRec的系统架构图
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
功能模块的设计与实现
\end_layout

\begin_layout Subsection
数据预处理模块 
\end_layout

\begin_layout Subsubsection
数据分割
\end_layout

\begin_layout Standard
在使用数据集之前，必须先将原始数据集进行分割为训练集和测试集。数据集一般储存为文本文件，每一行代表一个记录：用户对物品的一次评分，数据预处理模块的目的就是提取每
一条记录结构化为(userid,itemid,rate)的元组，分别表示为用户的id，物品的id和物品的评分，本文接下去也使用这种表述。从数据库设计角度来看us
erid,itemid是主键，也就是一个用户给一个物品只能有一条评分。
\end_layout

\begin_layout Standard
考虑到交叉验证的需求，如果使用K-fold交叉验证，那么经过风格后将产生
\begin_inset Formula $K$
\end_inset

个训练集和测试集对，其中训练集合和测试记录的比例为
\begin_inset Formula $K-1:K$
\end_inset

。可以直接将用户的平分为K份。章节
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:交叉验证与数据分割"

\end_inset

描述到分割数据时候，尽量为每个用户分割到足够的训练样本，这样才能有足够的信息产生推荐。因此为了方便让每个用户的数据足够，首先将对数据集中的每个记录按照useri
d排序，每K条进行一次随机排列，放入
\begin_inset Formula $K$
\end_inset

个缓冲区。最后在合并其中
\begin_inset Formula $K-1$
\end_inset

个缓冲区作为一个训练集，剩下一个作为测试集合。以下为python代码:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

def split(infile, outdir, k_fo):
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    infile: file to be split
\end_layout

\begin_layout Plain Layout

    outdir: output file directory
\end_layout

\begin_layout Plain Layout

    k_fo: the number for k fold cross validation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    this funtion will generate k paris of trains and testing data
\end_layout

\begin_layout Plain Layout

    '''
\end_layout

\begin_layout Plain Layout

    readfile = open(infile,'r')
\end_layout

\begin_layout Plain Layout

    #create k test files
\end_layout

\begin_layout Plain Layout

    test_files = []
\end_layout

\begin_layout Plain Layout

    for i in range(k_fo):
\end_layout

\begin_layout Plain Layout

        test_files.append(StringIO.StringIO())
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

    #split and write into to k stringIO buffer
\end_layout

\begin_layout Plain Layout

    count = 0 
\end_layout

\begin_layout Plain Layout

    rating_list_for_a_user = []
\end_layout

\begin_layout Plain Layout

    while True:
\end_layout

\begin_layout Plain Layout

        line = readfile.readline()
\end_layout

\begin_layout Plain Layout

        if not line :
\end_layout

\begin_layout Plain Layout

            append_to_stringIO(test_files, rating_list_for_a_user)
\end_layout

\begin_layout Plain Layout

            break
\end_layout

\begin_layout Plain Layout

        if count % k_fo == 0:
\end_layout

\begin_layout Plain Layout

            append_to_stringIO(test_files, rating_list_for_a_user)
\end_layout

\begin_layout Plain Layout

            rating_list_for_a_user = []
\end_layout

\begin_layout Plain Layout

        rating_list_for_a_user.append(line)
\end_layout

\begin_layout Plain Layout

        count += 1
\end_layout

\begin_layout Plain Layout

    readfile.close()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #generate k train and test file pairs
\end_layout

\begin_layout Plain Layout

    for i in range(k_fo):
\end_layout

\begin_layout Plain Layout

        with open("%s/train_%d.dat"%(outdir,i),"w") as f:
\end_layout

\begin_layout Plain Layout

            for j in range(k_fo):
\end_layout

\begin_layout Plain Layout

                test_files[j].seek(0)
\end_layout

\begin_layout Plain Layout

                if j != i:  #write to file
\end_layout

\begin_layout Plain Layout

                    for line in test_files[j]:
\end_layout

\begin_layout Plain Layout

                        f.write(line)
\end_layout

\begin_layout Plain Layout

        with open("%s/test_%d.dat"%(outdir,i),"w") as f:
\end_layout

\begin_layout Plain Layout

            for line in test_files[i]:
\end_layout

\begin_layout Plain Layout

                f.write(line)
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    for f in test_files:
\end_layout

\begin_layout Plain Layout

        f.close()
\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
其中第9行读入数据集，19行获取一个记录（即数据文件中的一行），21、24行的append_to_stringIO函数实现的功能是将长度为
\begin_inset Formula $K$
\end_inset

的列表重新随机排列后附在缓冲区的尾部。31～40的代码用于生成所需的测试集和数据集。
\end_layout

\begin_layout Subsubsection
数据导入
\end_layout

\begin_layout Standard
数据导入模块提供了从数据文件获取记录并且结构化的功能。如图
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:数据读取类图"

\end_inset

所示，Reader类接收数据文件路径（filepath）、评分记录模式（pattern)。评分记录模式是告诉Reader每一条记录是以什么结构在文本文件中组织的
。Reader可以通过getIterator方法来获取一个迭代器。类Iterator提供了三个方法get_all，get_next，以及get_net_dict
用来获取评分记录，他们分别返回记录列表，记录对象和以python字典格式的评分记录。在读取记录时，可以循环调用get_next等方法来获取，当记录读取完毕时，返
回None。
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename 数据导入类图.eps
	width 30col%

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:数据读取类图"

\end_inset

数据读取类图
\end_layout

\end_inset


\end_layout

\end_inset

下边的代码是一个使用Reader类将数据导入至Redis的例子：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{python}
\end_layout

\begin_layout Plain Layout

reader = Reader(data_path,data_sp,data_ptn)
\end_layout

\begin_layout Plain Layout

it = reader.get_iterator()
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

    record = it.get_next_dict()
\end_layout

\begin_layout Plain Layout

    if record == None:
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

    to_Redis(record)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Data from %s imported to redis." % data_path
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{python} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
DAO模块
\end_layout

\begin_layout Standard
DAO模块定义了存取或者获取数据的API，根据本推荐引擎TinyRec的需求，设计了如下API：
\end_layout

\begin_layout Standard
put_a_record(userid, itemid,rating)
\end_layout

\begin_layout Standard
存入具有userid的用户为具有itemid的物品给出评分rating的一条记录，即存入元组(userid,itemid,rating)。
\end_layout

\begin_layout Standard
get_item_list_by_user(userid)
\end_layout

\begin_layout Standard
通过userid获取用户他所有的评分记录，对应于用户
\begin_inset Formula $u$
\end_inset

评价的所有物品集合
\begin_inset Formula $I_{u}$
\end_inset

。该函数返回一组列表，列表里的每个元素是一个元组(itemid,rating),表示用户为具有itemid的物品的一条评分记录。
\end_layout

\begin_layout Standard
get_user_list_by_item(itemid)
\end_layout

\begin_layout Standard
通过itemid获取这个物品的得到的所有评分记录，对应于给物品
\begin_inset Formula $i$
\end_inset

评价的所有用户集合
\begin_inset Formula $U_{i}$
\end_inset

。该函数返回一组列表，列表里的每个元素是一个元组(userid,rating),表示具有userid的用户给其的一条评分记录。
\end_layout

\begin_layout Standard
get_rate(userid,itemid)
\end_layout

\begin_layout Standard
返回具有userid的用户给具有itemid的物品的一条评分记录，如果这条记录不存在，即用户未能给这个物品评分那么返回None。
\end_layout

\begin_layout Standard
get_user_rating_num(userid)
\end_layout

\begin_layout Standard
返回具有userid的用户评价的物品数量，即
\begin_inset Formula $\left|I_{u}\right|$
\end_inset

。
\end_layout

\begin_layout Standard
get_item_rating_num(userid)
\end_layout

\begin_layout Standard
返回具有itemid的物品得到用户的评价的数量,即
\begin_inset Formula $\left|U_{i}\right|$
\end_inset

。
\end_layout

\begin_layout Standard
put_item_sim(itemid,otheritemid,sim)
\end_layout

\begin_layout Standard
存入具有itemid的物品与具有otheritemid物品的相似度。
\end_layout

\begin_layout Standard
get_item_sim_list(itemid,k,bydesc)
\end_layout

\begin_layout Standard
返回与具有itemid最相似的前k个物品的列表，列表每个元素是一个元组(otheritemid,sim)，分别表示某个具有otheritemid的物品与当前物品
的相似度sim。bydesc表示是否按照相似度从大到小排列。
\end_layout

\begin_layout Standard
get_sim_between_two_items(itemid,otheritemid)
\end_layout

\begin_layout Standard
返回itemid与otheritemid的相似度
\end_layout

\begin_layout Standard
put_user_sim(userid,otheruser,sim)
\end_layout

\begin_layout Standard
存入具有userid的用户与具有otheruser的用户之间的相似度。
\end_layout

\begin_layout Standard
get_user_sim_list(userid,k,bydesc )
\end_layout

\begin_layout Standard
返回与具有userid最相似的前k个用户的列表，列表每个元素是一个元组(otheruser,sim)，分别表示某个具有otheruserid的用户与当前用户的相
似度sim。bydesc表示是否按照相似度从大到小排列。
\end_layout

\begin_layout Standard
get_sim_between_two_users(userid,otheritemid)
\end_layout

\begin_layout Standard
返回userid与otheruserid的相似度
\end_layout

\begin_layout Standard
get_user_rating_mean(userid)
\end_layout

\begin_layout Standard
返回用户的平均评分，即
\begin_inset Formula $\overline{r_{u}}$
\end_inset

。
\end_layout

\begin_layout Standard
get_item_rating_mean(item)
\end_layout

\begin_layout Standard
返回物品的平均评分，即
\begin_inset Formula $\overline{r_{i}}$
\end_inset

。
\end_layout

\begin_layout Standard
由于使用的是python语言，上述函数返回的数据结构，如列表、元组均为python提供的数据结构。
\end_layout

\begin_layout Subsection
数据存储模块
\end_layout

\begin_layout Standard
本模块即通过DAO模块存储数据用于为TinyRec提供临时或者永久的数据存储功能。在整个执行推荐的流程中，它需要存储基本的数据记录，计算得出的相似度等。Tiny
Rec支持使用内存数据库，关系数据库或者Nosql数据库等。根据推荐引擎的特点，不难得出数据存储必须满足下列要求：
\end_layout

\begin_layout Enumerate
由于计算相似度的需要，TinyRec需要从从数据存储处快速获取一条或者多条用户的评分记录，计算完毕之后将相似度存入。因此应当尽量保证低延迟，减少不必要的系统调用
与IO时间，让计算机CPU资源得到充分利用。
\end_layout

\begin_layout Enumerate
需要被存储的数据有不同的特点，比如某个物品的相似度存储需要按照大小有序排列，但是也要能够快速获取两个物品、两个用户之间的相似度。而用户与物品的评分记录可以无序存
放。
\end_layout

\begin_layout Standard
其中内存数据库相对于传统的关系数据库显然拥有更低的延迟与吞吐量，而支持SQL的关系数据库可以很容易地满足第二点要求。另外，本文使用的数据集较小，可以放入内存计算
。综合考虑，本文采用基于内存的，提供数据持久化功能的开源数据库Redis。Redis提供了许多数据结构，非常方便用户使用。根据不同数据的特点，本文如下设计数据的
存储结构：
\end_layout

\begin_layout Enumerate
评分记录的存储。首先，为每个用户建立一个hashset
\begin_inset Foot
status open

\begin_layout Plain Layout
本章节提到的数据结构均为Redis提供的数据结构
\end_layout

\end_inset

，用于存储该用户的评分记录。该hashset由用户id唯一标识，hashset内部存储(itemid,rating)的key-value对。在使用时，Redis
可以在
\begin_inset Formula $O(1)$
\end_inset

时间内根据给定用户id以及物品id获得或者存入对应的评分，也可以在
\begin_inset Formula $O(\left|I_{u}\right|)$
\end_inset

时间内获取用户评分的所有评分记录。为了方便地获取某个物品得到的评分记录，也为每个物品建立一个hashset，由物品id唯一标识，存储(userid,rating
)的评分记录，类似的Redis可以在
\begin_inset Formula $O(\left|U_{i}\right|)$
\end_inset

时间内获取该物品的得到用户的所有评分记录。
\end_layout

\begin_layout Enumerate
相似度的存储。为每个用户建立一个sorted set，存储(userid,sim)的key-value对，sim表示该用户与其他某个用户的相似度。为了节省空间的
需要，我们可以只存储与该用户最相似的前
\begin_inset Formula $K$
\end_inset

个用户，
\begin_inset Formula $K$
\end_inset

值大叫其实就是邻域的大小。Redis可以在
\begin_inset Formula $O(logK)$
\end_inset

时间内插入一条相似度记录，在
\begin_inset Formula $O(K)$
\end_inset

时间内取出按照相似度大小排列的一组用户列表，而根据两个用户id获取相似度只要
\begin_inset Formula $O(1)$
\end_inset

的时间。同样的我们也为每个物品建立相似的表，这里就不再赘述。
\end_layout

\begin_layout Subsection
相似度模块
\end_layout

\begin_layout Standard
本模块计算用户之间或者物品之间的相似度。首先通过DAO获取用户的评分记录，再利用稀疏向量库来计算相似度。
\end_layout

\begin_layout Subsubsection
稀疏向量运算库
\end_layout

\begin_layout Subsection
预测模块 
\end_layout

\begin_layout Subsection
精确度测量模块 
\end_layout

\begin_layout Subsection
Benchmark模块 
\end_layout

\begin_layout Subsection
参数配置模块 
\end_layout

\begin_layout Section
算法设计与实现 
\end_layout

\begin_layout Subsection
item-based协同过滤 
\end_layout

\begin_layout Subsection
user-based协同过滤 
\end_layout

\begin_layout Subsection
相似度度量 
\end_layout

\begin_layout Subsubsection
cos 
\end_layout

\begin_layout Subsubsection
pearson 实现的方法 化简 
\end_layout

\begin_layout Subsubsection
spearman 
\end_layout

\begin_layout Subsubsection
重要性权重 
\end_layout

\begin_layout Subsection
默认评分 
\end_layout

\begin_layout Subsection
knn预测 
\end_layout

\begin_layout Subsection
精确度评估 
\end_layout

\begin_layout Subsection
交叉验证
\end_layout

\begin_layout Chapter
评分预测实验 
\end_layout

\begin_layout Section
实验目的及内容 
\end_layout

\begin_layout Subsection
实验数据及实验方法 
\end_layout

\begin_layout Subsection
度量标准
\end_layout

\begin_layout Subsection
实验结果与分析
\end_layout

\begin_layout Subsection
相似度方法 cos,spearman,pearson,pearson-with default rate 
\end_layout

\begin_layout Subsection
knn k值选择 
\end_layout

\begin_layout Subsection
significance weighting 值选择 
\end_layout

\begin_layout Subsection
item-based vs user-based 
\end_layout

\begin_layout Subsection
4.4.4.5 。。
\end_layout

\begin_layout Chapter
未来的工作 
\end_layout

\begin_layout Chapter
结语
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
我草拟麻痹
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "seuthesis"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
